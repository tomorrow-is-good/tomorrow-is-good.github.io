<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>布隆过滤器</title>
      <link href="/posts/12923.html"/>
      <url>/posts/12923.html</url>
      
        <content type="html"><![CDATA[<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>​    布隆过滤器可以理解为一个不怎么精确的 set 结构，当你使用它的 contains 方法判断某个对象是否存在时，它可能会误判。但是布隆过滤器也不是特别不精确，只要参数设置的合理，它的精确度可以控制的相对足够精确，只会有小小的误判概率。</p><p>​    当布隆过滤器说某个值存在时，这个值可能不存在；当它说不存在时，那就肯定不存在。打个比方，当它说不认识你时，肯定就不认识；当它说见过你时，可能根本就没见过面，不过因为你的脸跟它认识的人中某脸比较相似 (某些熟脸的系数组合)，所以误判以前见过你。</p><h3 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a>二、原理</h3><p>​    布隆过滤器的原理是，当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。</p><p>​    Bloom Filter跟单哈希函数Bit-Map不同之处在于：Bloom Filter使用了k个哈希函数，每个字符串跟k个bit对应。从而降低了冲突的概率。</p><p><img src="/medias/loading.gif" data-original="https://i.loli.net/2020/12/06/AKYJz8Vtm7dI5Fw.jpg" alt=""></p><h3 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h3><blockquote><p>防止缓存击穿</p></blockquote><p>​    数据库的id都是1开始然后自增的，当接口是通过id查询的，我就拿负数去查询，这个时候，会发现缓存里面没这个数据，我又去数据库查也没有，一个请求这样，100个，1000个，10000个呢？你的DB基本上就扛不住了，如果在缓存里面加上这个，是不是就不存在了，你判断没这个数据就不去查了，直接return一个数据为空不就好了嘛。</p><blockquote><p>其它应用场景</p></blockquote><ul><li>爬虫过滤已抓到的url就不再抓，可用bloom filter过滤</li><li>垃圾邮件过滤。如果用哈希表，每存储一亿个 email地址，就需要 1.6GB的内存（用哈希表实现的具体办法是将每一个 email地址对应成一个八字节的信息指纹，然后将这些信息指纹存入哈希表，由于哈希表的存储效率一般只有 50%，因此一个 email地址需要占用十六个字节。一亿个地址大约要 1.6GB，即十六亿字节的内存）。因此存贮几十亿个邮件地址可能需要上百 GB的内存。而Bloom Filter只需要哈希表 1/8到 1/4 的大小就能解决同样的问题。</li><li>做推荐系统，要将之前推荐过的商品给去掉，可以使用bloom filter过滤</li></ul><h3 id="四、数学推导"><a href="#四、数学推导" class="headerlink" title="四、数学推导"></a>四、数学推导</h3><h4 id="误判概率的计算"><a href="#误判概率的计算" class="headerlink" title="误判概率的计算"></a>误判概率的计算</h4><p>​    假设布隆过滤器中的散列函数满足：每个元素都等概率的hash到m个bit中的任何一个，与其它元素被hash到哪个bit无关。若m为bit数，则对某一特定bit位在一个元素由某特定散列函数插入时没有被置位为1的概率为：</p><script type="math/tex; mode=display">1-\frac{1}{m}</script><p>​    则k个散列函数没有一个对其置位的概率为：</p><script type="math/tex; mode=display">(1-\frac{1}{m})^k</script><p>​    如果插入了n个元素，但都未将其置位的概率为：</p><script type="math/tex; mode=display">(1-\frac{1}{m})^{kn}</script><p>​    则此特定bit位被置位的概率为：</p><script type="math/tex; mode=display">1-(1-\frac{1}{m})^{kn}</script><p>​    当考虑查找的时候，因为有k个散列函数，则对应元素应该有k个bit。若对应元素的k bits全部被置位为1，则可判定其在集合中。因此将某元素误判的概率为：</p><script type="math/tex; mode=display">(1-(1-\frac{1}{m})^{kn})^k</script><script type="math/tex; mode=display">由于\lim_{x\rightarrow+\infty}(1+\frac{1}{x})^x=e,并且x趋于+\infty \\\lim_{m\rightarrow+\infty}(1-\frac{1}{m})^{-m}=e\\(1-(1-\frac{1}{m})^{kn})^k=(1-(1-\frac{1}{m})^{-m\frac{-kn}{m}})^k=(1-e^\frac{-kn}{m})^k</script><p>​    从上式可以看出，当m增大或n减小，都会是得误判率减小。</p><p>​    现在计算对于给定的m和n，k为何值时可以使得误判率最低。设误判率为k的函数为：</p><script type="math/tex; mode=display">f(k)=(1-e^\frac{-kn}{m})^k</script><script type="math/tex; mode=display">设b=e^\frac{n}{m},则简化为\\f(k)=(1-b^{-k})^k</script><p>​    采用对数求导法，该方法将幂函数、指数函数及幂指函数运算降格成为乘法运算，可将乘法运算或除法运算降格为加法或减法运算，使求导运算计算量大为减少。</p><script type="math/tex; mode=display">lnf(k)=k*ln(1-b^{-k}),两边对k求导\\\frac{1}{f(k)}*f'(k)=ln(1-b^{-k})+k*\frac{1}{1-b^{-k}}*(-b^{-k})*lnb*(-1)=ln(1-b^{-k})+k*\frac{b^{-k}lnb}{1-b^{-k}})\\f'(k)=(ln(1-b^{-k})+k*\frac{b^{-k}lnb}{1-b^{-k}})*f(k)</script><p>​    下面求最值</p><script type="math/tex; mode=display">(ln(1-b^{-k})+k*\frac{b^{-k}lnb}{1-b^{-k}})*f(k)=0\\ln(1-b^{-k})+k*\frac{b^{-k}lnb}{1-b^{-k}}=0\\(1-b^{-k})*ln(1-b^{-k})=-k*b^{-k}*lnb\\(1-b^{-k})*ln(1-b^{-k})=b^{-k}*lnb^{-k}\\1-b^{-k}=b^{-k}\\b^{-k}=\frac{1}{2}\\e^\frac{-kn}{m}=\frac{1}{2}\\\frac{-kn}{m}=ln\frac{1}{2}\\k=ln2*\frac{m}{n}</script><p>​    因此当k满足上式时误判率是最低的，此时误判率P为：</p><script type="math/tex; mode=display">P=(1-e^\frac{-kn}{m})^k=(1-e^{-ln2})^k=(1-\frac{1}{2})^k=2^{-k}=2^{-ln2\frac{m}{n}}</script><p>​    当误判率小于等于1/2，则</p><script type="math/tex; mode=display">2^{-k}\leq\frac{1}{2}\\2^{-k}\leq2^{-1}\\k\geq1\\\frac{m}{n}\geq\frac{1}{ln2}</script><p>​    </p><p>​    这说明了若想保持某固定误判率不变，布隆过滤器的bit数m与被add的元素数n应该是线性同步增加的。</p><h4 id="设计克隆过滤器"><a href="#设计克隆过滤器" class="headerlink" title="设计克隆过滤器"></a>设计克隆过滤器</h4><p>​    首先要先由用户决定要add的元素数n和希望的误差率P。这也是一个设计完整的布隆过滤器需要用户输入的仅有的两个参数，之后的所有参数将由系统计算，并由此建立布隆过滤器。</p><p>​    系统首先要计算需要的内存大小m bits：</p><script type="math/tex; mode=display">P=2^{-ln2\frac{m}{n}}\\lnP=ln2*(-ln2)*\frac{m}{n}\\m=-\frac{n*lnP}{(ln2)^2}</script><p>​    </p><p>​    再由m，n得到散列函数的个数：</p><script type="math/tex; mode=display">k=ln2*\frac{m}{n}</script><p>​    根据公式，当k最优时：</p><script type="math/tex; mode=display">P=2^{-k}\\\log_2P=-k\\k=\log_2\frac{1}{P}\\ln2*\frac{m}{n}=\log_2\frac{1}{P}\\\frac{m}{n}=\frac{\log_2\frac{1}{P}}{ln2}\\\frac{m}{n}=\log_2\frac{1}{P}*1.44\\</script><p>​    当P=1%时，m为内存会计，n为元素个数则存储每个元素需要9.6bits：</p><script type="math/tex; mode=display">\frac{m}{n}=1.44*\log_2\frac{1}{0.01}=1.44*\log_2100=9.6bits</script><p>​    这里需要特别注意的是，9.6 bits不仅包含了被置为1的k位，还把包含了没有被置为1的一些位数。此时的k</p><script type="math/tex; mode=display">k=ln2*\frac{m}{n}=ln2*9.6=6.65bits才是对应的为1的bit位数</script><h3 id="五、实现"><a href="#五、实现" class="headerlink" title="五、实现"></a>五、实现</h3><h4 id="使用准备"><a href="#使用准备" class="headerlink" title="使用准备"></a>使用准备</h4><pre><code class="lang-xml">&lt;dependency&gt;    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;    &lt;artifactId&gt;guava&lt;/artifactId&gt;    &lt;version&gt;23.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><pre><code class="lang-java">public class TestBloomFilter {    //添加的元素数量    private static int total=1000000;    private static BloomFilter&lt;Integer&gt; bloomFilter=BloomFilter.create(Funnels.integerFunnel(),total);    public static void main(String[] args) {        // 初始化1000000条数据到过滤器中        for(int i=0;i&lt;total;i++){            bloomFilter.put(i);        }         // 匹配已在过滤器中的值，是否有匹配不上的        for(int i=0;i&lt;total;i++){            if(!bloomFilter.mightContain(i)){                System.out.println(&quot;有坏人逃脱了~~~&quot;);            }        }         // 匹配不在过滤器中的10000个值，有多少匹配出来        int count=0;        for(int i=total;i&lt;total+10000;i++){            if(bloomFilter.mightContain(i)){                count++;            }        }        System.out.println(&quot;误伤的数量：&quot; + count);    }}</code></pre><p>​    运行结果表示，遍历这一百万个在过滤器中的数时，都被识别出来了。一万个不在过滤器中的数，误伤了320个，错误率是0.03左右。</p><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><blockquote><p>创建对象</p></blockquote><pre><code class="lang-java">public static &lt;T&gt; BloomFilter&lt;T&gt; create(Funnel&lt;? super T&gt; funnel, int expectedInsertions) {        return create(funnel, (long) expectedInsertions);    }      public static &lt;T&gt; BloomFilter&lt;T&gt; create(Funnel&lt;? super T&gt; funnel, long expectedInsertions) {        return create(funnel, expectedInsertions, 0.03); // FYI, for 3%, we always get 5 hash functions    }    public static &lt;T&gt; BloomFilter&lt;T&gt; create(          Funnel&lt;? super T&gt; funnel, long expectedInsertions, double fpp) {        return create(funnel, expectedInsertions, fpp, BloomFilterStrategies.MURMUR128_MITZ_64);    }    static &lt;T&gt; BloomFilter&lt;T&gt; create(      Funnel&lt;? super T&gt; funnel, long expectedInsertions, double fpp, Strategy strategy) {     ......    }</code></pre><p>BloomFilter一共四个create方法，不过最终都是走向第四个。看一下每个参数的含义：</p><ul><li>funnel：数据类型(一般是调用Funnels工具类中的)</li><li>expectedInsertions：期望插入的值的个数</li><li>fpp ： 错误率(默认值为0.03)</li><li>strategy： 哈希算法</li></ul><blockquote><p>分析create方法</p></blockquote><pre><code class="lang-java">static &lt;T&gt; BloomFilter&lt;T&gt; create(      Funnel&lt;? super T&gt; funnel, long expectedInsertions, double fpp, Strategy strategy) {    if (expectedInsertions == 0) {      expectedInsertions = 1;    }       //计算内存，通过插入的值的个数和错误率来计算    long numBits = optimalNumOfBits(expectedInsertions, fpp);    //计算散列函数的个数    int numHashFunctions = optimalNumOfHashFunctions(expectedInsertions, numBits);    try {        //创建对象      return new BloomFilter&lt;T&gt;(new LockFreeBitArray(numBits), numHashFunctions, funnel, strategy);    } catch (IllegalArgumentException e) {      throw new IllegalArgumentException(&quot;Could not create BloomFilter of &quot; + numBits + &quot; bits&quot;, e);    }  }</code></pre><pre><code class="lang-java">//计算内存，通过插入的值的个数和错误率来计算static long optimalNumOfBits(long n, double p) {    if (p == 0) {      p = Double.MIN_VALUE;    }    return (long) (-n * Math.log(p) / (Math.log(2) * Math.log(2)));  }</code></pre><p>对应公式：</p><script type="math/tex; mode=display">m=-\frac{n*lnP}{(ln2)^2}</script><pre><code class="lang-java">//计算散列函数的个数static int optimalNumOfHashFunctions(long n, long m) {    // (m / n) * log(2), but avoid truncation due to division!    return Math.max(1, (int) Math.round((double) m / n * Math.log(2)));  }</code></pre><p>对应公式：</p><script type="math/tex; mode=display">k=ln2*\frac{m}{n}</script>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
