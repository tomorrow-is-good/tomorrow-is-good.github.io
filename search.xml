<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mysql</title>
      <link href="/posts/13153.html"/>
      <url>/posts/13153.html</url>
      
        <content type="html"><![CDATA[<h2 id="第一部分-mysql的使用"><a href="#第一部分-mysql的使用" class="headerlink" title="第一部分 mysql的使用"></a>第一部分 mysql的使用</h2><h3 id="一、数据库"><a href="#一、数据库" class="headerlink" title="一、数据库"></a>一、数据库</h3><pre><code class="lang-mysql"># 新建数据库create database exampleDataBase;# 使用数据库use exampleDataBase;# 删除数据库delete database exampleDataBase;</code></pre><h3 id="二、表"><a href="#二、表" class="headerlink" title="二、表"></a>二、表</h3><p>​    <strong>新建基本表</strong></p><pre><code class="lang-mysql">create table &lt;表名&gt;(    &lt;列名&gt; &lt;数据类型&gt; &lt;列级完整性约束条件&gt; ,    ... ,    &lt;表级完整性约束条件&gt;)engine=&lt;引擎名&gt;# ex:create table user(    # int类型 自增健    id int auto_increment ,    # 变长字符串类型 可为空     name varchar(20) null ,    # 设置主键为id 主键不可为空    primary key(id))engine=innodb</code></pre><p>​    <strong>更新基本表</strong></p><pre><code class="lang-mysql">#添加列alter table &lt;表名&gt; add &lt;列名&gt; &lt;数据类型&gt; &lt;列级完整性约束条件&gt;;# ex: int类型 不可为空alter table user add age int not null;#删除列alter table &lt;表名&gt; drop column &lt;列名&gt;;# ex:alter table user drop column age;</code></pre><p>​    <strong>删除基本表</strong></p><pre><code class="lang-mysql">drop table &lt;表名&gt;;</code></pre><p>​    <strong>重命名基本表名</strong></p><pre><code class="lang-mysql">rename table &lt;旧表名&gt; to &lt;新表名&gt;;</code></pre><p>​    <strong>新建临时表</strong></p><pre><code class="lang-mysql">create temporary table &lt;表名&gt;...</code></pre><p>​    <strong>临时表的特点：</strong></p><ul><li>一个临时表只能被创建它的线程访问，对其他线程不可见</li><li>临时表可以与普通表同名</li><li>线程内有有同名的临时表和普通表的时候以及增删改查语句访问的是临时表。##</li></ul><h3 id="三、插入数据"><a href="#三、插入数据" class="headerlink" title="三、插入数据"></a>三、插入数据</h3><p>​    <strong>插入完整的行</strong></p><pre><code class="lang-mysql"># values子句括号里面对应表的每一列insert into &lt;表名&gt; values(&lt;常量1&gt;,&lt;常量2&gt;,...);# ex: 例表的id列为自增健insert into user values(null,&quot;lxt&quot;);</code></pre><p>​    <strong>插入特定属性列</strong></p><pre><code class="lang-mysql"># values子句提供的值必须与into子句的属性列相匹配insert into &lt;表名&gt;(&lt;属性列1&gt;,&lt;属性列2&gt;,...)values(&lt;常量1&gt;,&lt;常量2&gt;,...);# ex:insert into user(name) values(&quot;lxt&quot;);</code></pre><p>​    <strong>将一个表的内容插入到一个新表</strong></p><pre><code class="lang-mysql">create table &lt;表名&gt; as select * from &lt;表名&gt;;# ex:create table user1 as select * from user;</code></pre><p>​    <strong>插入检索出来的数据</strong></p><pre><code class="lang-mysql"># into子句的属性列必须与select子句后面的属性列相匹配insert into &lt;表名&gt;(&lt;属性列1&gt;,&lt;属性列2&gt;,...)select &lt;属性列1&gt;,&lt;属性列2&gt;,... from &lt;表名&gt;;# ex:insert into user(name) select name from user1;</code></pre><h3 id="四、更新和删除数据"><a href="#四、更新和删除数据" class="headerlink" title="四、更新和删除数据"></a>四、更新和删除数据</h3><p>​    <strong>更新数据</strong></p><pre><code class="lang-mysql">update &lt;表名&gt;set &lt;属性列1&gt;=&lt;常量1&gt;,&lt;属性列2&gt;=&lt;常量2&gt;...where &lt;条件&gt;;# ex:update user set name=&quot;ljx&quot; where id=2;</code></pre><p>​    <strong>删除数据</strong></p><pre><code class="lang-mysql">delete from &lt;表名&gt;where &lt;条件&gt;;# ex:delete from user where id=2;</code></pre><p>​    <strong>清空表中的数据</strong></p><pre><code class="lang-mysql"># truncate table语句实际上是删除原来的表重新创建一个表truncate table &lt;表名&gt;;</code></pre><p>​    在更新和删除数据时一定要使用where子句</p><h3 id="五、查询"><a href="#五、查询" class="headerlink" title="五、查询"></a>五、查询</h3><p>​    <strong>查询列</strong></p><pre><code class="lang-mysql">select &lt;属性列1&gt;,&lt;属性列2&gt;,... from &lt;表名&gt;;# 查询所有列select * from &lt;列名&gt;;</code></pre><p>​    <strong>查询不同的行，相同值只出现一次。distinct关键字作用于所有列而不仅仅是前置它的列</strong></p><pre><code class="lang-mysql">select distinct &lt;属性列1&gt;,&lt;属性列2&gt;,... from &lt;表名&gt;;</code></pre><p>​    <strong>限制结果limit，可以有两个也可以有一个参数</strong></p><pre><code class="lang-mysql"># 以x行为开头，返回下面的y行数据select &lt;属性列1&gt;,&lt;属性列2&gt;,... from &lt;表名&gt; limit x,y;# 返回前x行数据select &lt;属性列1&gt;,&lt;属性列2&gt;,... from &lt;表名&gt; limit x;</code></pre><h3 id="六、排序查询"><a href="#六、排序查询" class="headerlink" title="六、排序查询"></a>六、排序查询</h3><p>​    <strong>单列排序</strong></p><pre><code class="lang-mysql"># 按照属性列1来进行升序select  &lt;属性列1&gt;,&lt;属性列2&gt;,... from &lt;表名&gt; order by &lt;属性列1&gt;# 按照属性列1来进行降序select  &lt;属性列1&gt;,&lt;属性列2&gt;,... from &lt;表名&gt; order by &lt;属性列1&gt; desc</code></pre><p>​    <strong>多列排序</strong></p><pre><code class="lang-mysql"># 首先按照属性列1来降序,然后按照属性列2进行降序select &lt;属性列1&gt;,&lt;属性列2&gt;,... from &lt;表名&gt; order by &lt;属性列1&gt; desc,&lt;属性列2&gt;</code></pre><p>​    order by 子句必须在from子句后面，如果使用limit子句，它必须位于order by 子句后面。</p><h3 id="七、过滤"><a href="#七、过滤" class="headerlink" title="七、过滤"></a>七、过滤</h3><p>​    数据库表含有大量的数据，通常只需要特定的数据。尽量使用 SQL 语句来过滤不必要的数据，而不是传输所有的数据到客户端中然后由客户端进行过滤。</p><p>​    <strong>下表是常用的查询条件</strong></p><div class="table-container"><table><thead><tr><th>查询条件</th><th>谓词</th></tr></thead><tbody><tr><td>比较</td><td>=, &gt;, &lt;, &gt;=, &lt;=, !=, &lt;&gt;, !&gt;, !&lt;上述比较运算符</td></tr><tr><td>确定范围</td><td>between and , not between and</td></tr><tr><td>确定集合</td><td>in , not in</td></tr><tr><td>字符匹配</td><td>like , not like</td></tr><tr><td>空值</td><td>is null , is not null</td></tr><tr><td>多重条件</td><td>and , or , not</td></tr></tbody></table></div><p>​    当一个列不包含值时可以称其为空值null。null与字段包含0、空字符串或仅仅包含空格不同。</p><pre><code class="lang-mysql"># 查询id为1的数据行select * from user where id=1;# 查询id大于1的数据行select * from user where id&gt;1;# 查询id小于1的数据行select * from user where id&lt;1;# 查询id大于等于1的数据行select * from user where id&gt;=1;# 查询id小于等于1的数据行select * from user where id&lt;=1;# 查询id不等于1的数据行select * from user where id!=1;# 查询id不等于1的数据行select * from user where id&lt;&gt;1;# 查询id小于等于1的数据行select * from user where id!&gt;1;# 查询id大于等于1的数据行select * from user where id!&lt;1;# 查询id从1到5的数据行select * from user where id between 1 and 5;# 查询id不是从1到5的数据行select * from user where id not between 1 and 5;# 查询id是1或者3的数据行select * from user where id in(1,3);# 查询id不是1或者3的数据行select * from user where id not in(1,3);# 查询name为空值的数据行select * from user where name is null;# 查询name不为空值的数据行select * from user where name is not null;</code></pre><p>​    and操作符代表并，or操作符代表或。当where子句后有任意数目的and和or操作符，它将会优先处理and操作符。在where子句后使用任何and和or操作符时应该使用圆括号明确地分组操作符，可以使得优先级关系更清晰。</p><pre><code class="lang-mysql">#  查询id为1并且name为lxt的数据行select * from user where id=1 and name=&quot;lxt&quot;;# 查询id为1或2的数据行 in操作符也可以达到这种效果但尽量使用in操作符,这样语义清晰select * from user where id=1 or id=2;</code></pre><p>​    <strong>字符匹配 like &lt;匹配串&gt; 和 not like &lt;匹配串&gt;</strong>。匹配串可以是一个完整的字符串也可以包含通配符 % 和 _。</p><ul><li>% ：代表任意长度的字符串</li><li>_   ：代表任意单个字符</li></ul><pre><code class="lang-mysql"># 查询name开头为l的数据行select * from user where name like &quot;l%&quot;;# 查询name结尾为l的数据行select * from user where name like &quot;%l&quot;;# 查询name包含文本l的数据行select * from user where name like &quot;%l%&quot;;# 查询name为l*的数据行比如li,ly等等select * from user where name like &quot;l_&quot;;# 查询name为*l的数据行比如il,yl等等select * from user where name like &quot;_l&quot;;# 查询name为*l*的数据行比如ili,yly等等select * from user where name like &quot;_l_&quot;;</code></pre><p>​    不要滥用通配符，通配符位于开头匹配会非常慢并且如果匹配的字段加了索引，开头匹配将不会使用索引。</p><h3 id="八、计算字段"><a href="#八、计算字段" class="headerlink" title="八、计算字段"></a>八、计算字段</h3><p>​    <strong>拼接字段</strong>，在数据库服务器上完成数据的转换和格式化比在客户机中完成要快的多。</p><pre><code class="lang-mysql"># Concat()需要一个或多个指定的串，各个串之间要用逗号分隔。# 将每一行的id和name拼接在一起select Concat(id,name) from user;</code></pre><p>​    <strong>别名</strong>，别名分为列别名和表别名。别名的作用就是将查询出来的数据用别的名字来代替。别名用as关键字来代替</p><pre><code class="lang-mysql"># 列别名select Concat(id,name) as idName  form user;# 列别名select Concat(id,name) idName  form user;# 表别名select userNew.id from user as userNew;# 表别名select userNew.id from user userNew;</code></pre><p>​    select子句后面的列字段都可以进行算术计算的。</p><h3 id="九、函数"><a href="#九、函数" class="headerlink" title="九、函数"></a>九、函数</h3><pre><code> **文本处理函数**</code></pre><div class="table-container"><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>Left()</td><td>返回串左边的字符</td></tr><tr><td>Length()</td><td>返回串的长度</td></tr><tr><td>Locate()</td><td>找出串的一个子串</td></tr><tr><td>Lower()</td><td>将串转换为小写</td></tr><tr><td>LTrim()</td><td>去掉串左边的空格</td></tr><tr><td>Right()</td><td>返回串右边的字符</td></tr><tr><td>RTrim()</td><td>去掉串右边的空格</td></tr><tr><td>Soundex()</td><td>返回串的SOUNDEX值</td></tr><tr><td>SubString()</td><td>返回子串的字符</td></tr><tr><td>Upper()</td><td>将串转换为大写</td></tr></tbody></table></div><pre><code class="lang-mysql"># 返回name字段从左开始的2个字符select Left(name,2) from user;# 返回name字段从右开始的2个字符select Right(name,2) from user;# 去掉name字段左边的空格select LTrim(name) from user;# 去掉name字段右边的空格select RTrim(name) from user;# 去掉name字段shou&#39;wei的空格select Trim(name) from user;# 返回name字段的小写select Lower(name) from user;# 返回name字段的大写select Upper(name) from user;# 返回name字段的字符长度select Length(name) from user;# substring(参数1，参数2，参数3)，其中三个参数分别表示：参数1表示需要截取的字符串，参数2表示从字符串的那个位置开始截取（字符串下标从1开始），参数3表示要截取多少位，如果不写，表示截取从参数2指定的位置开始剩下的全部字符。# 返回name字段从第一个字符开始 截取2位select SubString(name,1,2) from user;</code></pre><p>​    <strong>日期和时间处理函数</strong></p><ul><li>日期格式：yyyy-mm-dd 插入更新都要用这种格式</li><li>时间格式：HH:MM:SS 插入更新都要用这种格式</li></ul><div class="table-container"><table><thead><tr><th>函 数</th><th>说 明</th></tr></thead><tbody><tr><td>AddDate()</td><td>增加一个日期（天、周等）</td></tr><tr><td>AddTime()</td><td>增加一个时间（时、分等）</td></tr><tr><td>CurDate()</td><td>返回当前日期</td></tr><tr><td>CurTime()</td><td>返回当前时间</td></tr><tr><td>Date()</td><td>返回日期时间的日期部分</td></tr><tr><td>DateDiff()</td><td>计算两个日期之差</td></tr><tr><td>Date_add()</td><td>高度灵活的日期运算函数</td></tr><tr><td>Date_Format()</td><td>返回一个格式化的日期或时间串</td></tr><tr><td>Day()</td><td>返回一个日期的天数部分</td></tr><tr><td>DayOfWeek()</td><td>对于一个日期，返回对应的星期几</td></tr><tr><td>Hour()</td><td>返回一个时间的小时部分</td></tr><tr><td>Minute()</td><td>返回一个时间的分钟部分</td></tr><tr><td>Month()</td><td>返回一个日期的月份部分</td></tr><tr><td>Now()</td><td>返回当前日期和时间</td></tr><tr><td>Second()</td><td>返回一个时间的秒部分</td></tr><tr><td>Time()</td><td>返回一个日期时间的时间部分</td></tr><tr><td>Year()</td><td>返回一个日期的年份部分</td></tr></tbody></table></div><pre><code class="lang-mysql"># 实例表中并没有表示日期的字段,需修改表的结构# 为实例表user插入一个生日字段 birthday 类型为timestampalter table user add birthday timestamp null;# 为实例表user插入一行数据insert into user values(null,&quot;wy&quot;,&quot;2020-10-27&quot;);# 返回birthday的年部分select Year(birthday) from user;# 返回birthday的月部分select Month(birthday) from user;# 返回birthday的日部分select Day(birthday) from user;# 返回当前日期和时间select Now();</code></pre><p>​    <strong>数值处理函数</strong></p><div class="table-container"><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>Abs()</td><td>返回一个数的绝对值</td></tr><tr><td>Cos()</td><td>返回一个角度的余弦</td></tr><tr><td>Exp()</td><td>返回一个数的指数值</td></tr><tr><td>Mod()</td><td>返回除操作的余数</td></tr><tr><td>Pi()</td><td>返回圆周率</td></tr><tr><td>Rand()</td><td>返回一个随机数</td></tr><tr><td>Sin()</td><td>返回一个角度的正弦</td></tr><tr><td>Sqrt()</td><td>返回一个数的平方根</td></tr><tr><td>Tan()</td><td>返回一个角度的正切</td></tr></tbody></table></div><p>​    <strong>聚集函数</strong></p><div class="table-container"><table><thead><tr><th>函 数</th><th>说 明</th></tr></thead><tbody><tr><td>AVG()</td><td>返回某列的平均值</td></tr><tr><td>COUNT()</td><td>返回某列的行数</td></tr><tr><td>MAX()</td><td>返回某列的最大值</td></tr><tr><td>MIN()</td><td>返回某列的最小值</td></tr><tr><td>SUM()</td><td>返回某列值之和</td></tr></tbody></table></div><pre><code class="lang-mysql"># 返回所有id值的平均值select AVG(id) from user;# 使用count(*) 对表中所有的数目进行计数，无论表中包含的空值还是非空值# 使用count(column)对表中特定列进行计数，忽略null值# 返回id此列的行数select COUNT(id) from user;# 返回id此列的最大值idselect MAX(id) from user;# 返回id此列的最小值idselect MIN(id) from user;# 返回所有id值的总值select SUM(id) from user;</code></pre><h3 id="十、分组数据"><a href="#十、分组数据" class="headerlink" title="十、分组数据"></a>十、分组数据</h3><p>​    <strong>分组数据</strong>就是将具有相同的值放在同一组，以便对每个组进行聚集计算。分组是使用group by 子句建立的，并且group by 字段将分组字段进行排序。</p><pre><code class="lang-mysql"># 将具有相同生日字段birthday进行分组select birthday,count(*) num from user group by birthday;</code></pre><p>​    <strong>过滤分组</strong>，where子句过滤的是行，而having子句过滤的是组。having子句支持所有的where子句操作符。</p><pre><code class="lang-mysql"># 将具有相同生日字段birthday进行分组 并返回每一个分组个数大于2的分组select birthday,count(*) num from user group by birthday having count(*)&gt;2;</code></pre><p>​    <strong>使用规定</strong></p><ul><li>如果分组列中具有null值，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组。 </li><li>group by子句必须出where子句之后，order by子句之前。</li><li>group by子句中列出的每个列都必须是检索列或有效的表达式但不能是聚集函数。</li></ul><h3 id="十一、子查询"><a href="#十一、子查询" class="headerlink" title="十一、子查询"></a>十一、子查询</h3><p>​    <strong>使用规定</strong></p><ul><li>子查询中只能返回一个字段的数据。</li><li>在where子句中使用子查询，应保证select语句具有与where子句中相同数目的列。</li><li>子查询不能使用order by 子句。</li></ul><p>​    <strong>带有in谓词的子查询</strong></p><pre><code class="lang-mysql"># 查询id值从1到3的name字段相同的数据行select id,name from user where name in (select name from user where id between 1 and 3 );</code></pre><p>​    <strong>带有比较运算符的子查询</strong></p><pre><code class="lang-mysql"># 当能确切知道内层查询返回单值时，可用比较运算符（&gt;，&lt;，=，&gt;=，&lt;=，!=或&lt;&gt;）# 查询与id为3的生日字段birthday相同的数据行select id,name,birthday from user where birthday =(select birthday from user where id=3);# 查询大于id为3的生日字段birthday的数据行select id,name,birthday from user where birthday &gt;(select birthday from user where id=3);# 查询小于id为3的生日字段birthday数据行select id,name,birthday from user where birthday &lt;(select birthday from user where id=3);# 查询与id为3的生日字段birthday不相同的数据行select id,name,birthday from user where birthday !=(select birthday from user where id=3);</code></pre><p>​    <strong>exists谓词</strong></p><ul><li>带有exists谓词的子查询不返回任何数据，只产生逻辑真值”true”或逻辑假值”false”。若内层查询结果非空，则外层的where子句返回真值。若内层查询结果为空，则外层的where子句返回假值。</li><li>由exists引出的子查询，其目标列表达式通常都用*</li></ul><p>​    <strong>not exists 谓词</strong></p><ul><li>若内层查询结果非空，则外层的where子句返回假值。若内层查询结果为空，则外层的where子句返回真值。</li></ul><pre><code class="lang-mysql"># 使用exists谓词 内层查询一般要与外层查询相联结# 查询id值从1到3的name字段相同的数据行select id,name,birthday from user where exists (select * from user userNew where user.birthday=userNew.birthday and id between 1 and 3 )# 查询大于id为3的生日字段birthday的数据行select id,name,birthday from user where exists (select * from user userNew where user.birthday&gt;userNew.birthday and id=3);#所有带in谓词、比较运算符都能用带exists谓词的子查询等价替换。</code></pre><h3 id="十一、联结"><a href="#十一、联结" class="headerlink" title="十一、联结"></a>十一、联结</h3><p>​    分解数据可以为多个表能更有效地存储，更方便地处理，使用联结可以将多个表进行关联从而得到有效的数据。联结可以替换子查询，并且比子查询的效率一般更快一些。</p><p>​    <strong>等值联结</strong></p><pre><code class="lang-mysql"># 等值连接又称内连接，使用inner join关键字#当使用这种语法时,联结条件是用特定的on子句而不是where子句,但传递on的实际条件和where相同# 由于实例表只有一个表，从而要新建一个成绩表gradecreate table grade(    id int auto_increment,    name varchar(20) null,    score int null,    primary key(id))engine=innodb#插入数据insert into grade(name,score) values(&quot;lxt&quot;,80);insert into grade(name,score) values(&quot;ljx&quot;,90);# 以user表和grade表的相同字段name来作为联结条件select user.name,user.birthday,grade.score from user inner join grade on grade.name=user.name</code></pre><p>​    可以不明确使用inner join，而使用普通查询并在 where中将两个表中要连接的列用等值方法连接起来。</p><pre><code class="lang-mysql"># 以user表和grade表的相同字段name来作为联结条件select user.name,user.birthday,grade.score from user,grade where grade.name=user.name</code></pre><p>​    <strong>非等值联结</strong>，就是笛卡尔积。集合(a,b)和集合(c,d)的笛卡尔积就是(a,c)，(a,d)，(b,c)，(b,d)。表也是如此，每一行就相当于集合中的一个元素。由没有联结条件的表关系返回的结果为笛卡儿积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。</p><p>​    <strong>自联结</strong>，自联结可以看作等值联结的一种，只是联结的表是自身。</p><pre><code class="lang-mysql"># 查询与id为3的生日字段birthday相同的数据行select u1.id,u1.name,u1.birthday from user u1 inner join user u2 on u2.id=3 and u2.birthday=u1.birthday# 不用inner join 关键字select u1.id,u1.name,u1.birthday from user u1, user u2 where u2.id=3 and u2.birthday=u1.birthday</code></pre><p>​    子查询也可以做到，所以联结和子查询都是可以互相替代的。</p><p>​    <strong>自然联结</strong>，是把同名列通过等值联结起来的，同名列可以有多个。等值联结和自然联结的区别：等值联结提供连接的列，而自然联结自动联结所有同名列。自然联结通过natural join关键字实现。</p><pre><code class="lang-mysql">select user.name,user.birthday,grade.score from user natural join grade</code></pre><p>​    <strong>外联结</strong>，外联结保留了没有关联的那些行。分为左外联结，右外联结和全外联结(mysql不支持圈外联结)。</p><pre><code class="lang-mysql"># 左外联结是保留左表中没有关联的行,以左表为主体# user是驱动表 grade是被驱动表 尽量选择数据少的表作为驱动表 数据大的表作为被驱动表select user.name,user.birthday,grade.score from grade left outer join user on grade.name=user.name</code></pre><p>​    <em>实例表user的数据如下</em></p><p><img src="/medias/loading.gif" data-original="https://i.loli.net/2020/10/28/DQIkRSvq8ziHZYO.png" alt=""></p><p>​    <em>实例表grade的数据如下</em></p><p><img src="/medias/loading.gif" data-original="https://i.loli.net/2020/10/28/VrvFNGaD3wg6XhL.png" alt=""></p><p>​    <em>左外联结得到的数据如下</em></p><p><img src="/medias/loading.gif" data-original="https://i.loli.net/2020/10/28/lrLqTDZvSAPft8z.png" alt=""></p><p>​    </p><pre><code class="lang-mysql"># 右外联结是保留右表中没有关联的行,以右表为主体#  grade是驱动表 user是被驱动表select user.name,user.birthday,grade.score from grade right outer join user on grade.name=user.name</code></pre><p>​    <em>右外联结得到的数据如下</em></p><p><img src="/medias/loading.gif" data-original="https://i.loli.net/2020/10/28/pEoJTqOFU6sr3yg.png" alt=""></p><p>​    <strong>外联结和普通联结的区别</strong></p><ul><li>普通联结操作只输出满足连接条件的元组</li><li>外联结操作以指定表为连接主体，将主体表中不满足连接条件的元组一并输出</li></ul><h3 id="十二、组合查询"><a href="#十二、组合查询" class="headerlink" title="十二、组合查询"></a>十二、组合查询</h3><p>​    <strong>union关键字</strong> ,可用来组合数条SQL查询。利用union，可给出多条SELECT语句，将它们的结果组合成单个结果集。 </p><pre><code class="lang-mysql"># union会默认去掉重复的行select id ,name from user union select id,name from user# union all 不会去掉重复的行 如果知道组合的数据不会有重复值就用union allselect id ,name from user union all select id,name from user</code></pre><p>​    <strong>union规则</strong></p><ul><li>union必须由两条或两条以上的select语句组成，语句之间用关 键字union分隔。</li><li>union中的每个查询必须包含相同的列、表达式或聚集函数(次序无关紧要)。</li></ul><h3 id="十三、约束"><a href="#十三、约束" class="headerlink" title="十三、约束"></a>十三、约束</h3><p>​    <strong>主键约束</strong>，用primary key来实现。主键不可为空，唯一标识，不能有重复值，它的作用是用来保证数据完整性的。一个表只能有一个主键。</p><pre><code class="lang-mysql"># 主键就是主码,主码可以包含一个或者多个元素的# 在create table里实现primary key(&lt;列名&gt;,&lt;列名&gt;,...)</code></pre><p>​    <strong>主键原则</strong></p><ul><li>主键可以有多列的，但应该是单列的</li><li>不要将表中与业务相关的字段设置为主键，可以使用自增键id来实现的</li><li>永远不要去更新主键</li><li><p>主键不应该包含态变化的数据</p><p>   <strong>外键约束</strong>，用foreign key来实现。表的外键是另一表的主键, 外键可以有重复的, 可以为空。它的作用是用来与其他表来建立联系的。一个表可以有多个外键，但尽量不要使用外键，一切外键概念就在应用层实现。</p></li></ul><pre><code class="lang-mysql"># 在create table里实现# 此表就是参照表 下面的表名就是被参照表foreign key(&lt;列名&gt;) references &lt;表名&gt;&lt;列名&gt;</code></pre><p>​    <strong>属性上的约束条件</strong></p><pre><code class="lang-mysql"># 在create table里实现# 不允许取空值&lt;列名&gt; &lt;类型&gt; not null# 列值唯一且不允许取空值&lt;列名&gt; &lt;类型&gt; unique not null# 用check指定列值应该满足的条件&lt;列名&gt; &lt;类型&gt; check (&lt;条件&gt;)# exscore int check(score&gt;=0 and score&lt;=100)</code></pre><p>​    <strong>完整的约束命名子句</strong></p><pre><code class="lang-mysql">constraint &lt;完整性约束条件名&gt; &lt;完整性约束条件&gt;&lt;完整性约束条件&gt;包括not null、unique、primary key、foreign key、check等# ex:constraint c1 foreign key(&lt;列名&gt;) references &lt;表名&gt;&lt;列名&gt;# 删除表中的某一约束alter table &lt;表名&gt; drop constraint &lt;完整性约束条件名&gt;</code></pre><h3 id="十三、事务管理"><a href="#十三、事务管理" class="headerlink" title="十三、事务管理"></a>十三、事务管理</h3><p>​    <strong>基本术语：</strong></p><ul><li>事务（transaction）指一组 SQL 语句；</li><li>回退（rollback）指撤销指定 SQL 语句的过程；</li><li>提交（commit）指将未存储的 SQL 语句结果写入数据库表；</li><li>保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。</li></ul><p>​    事务处理用来管理INSERT、UPDATE和 DELETE语句但是不能回退SELECT语句。</p><p>​    MySQL 的事务提交默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。</p><p>​    设置 autocommit 为 0 可以取消自动提交；autocommit 标记是针对每个连接而不是针对服务器的。</p><p>​    如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点。</p><pre><code class="lang-mysql"># 一个简单的事务start transaction;...;...;commit;start transaction;...;...;rollback;# 使用savepoint保留点start transaction;...;savepoint &lt;保留点名1&gt;;...;savepoint &lt;保留点名2&gt;;...;rollback to &lt;保留点名1&gt;;commit;# 更改默认的提交行为set autocommit=0;# insert,delete或update语句  执行完下面的语句会发现表没有改变...;# 显式地提交 会发现表改变了  也可以回退 rollback;commit;</code></pre><h3 id="十四、权限管理"><a href="#十四、权限管理" class="headerlink" title="十四、权限管理"></a>十四、权限管理</h3><p>​    mysql服务器的安全基础是：用户应该对他们需要的数据具有适当的访问权，既不能多也不能少。换句话说，用户不能对过多的数据具有 过多的访问权。 </p><p>​    <strong>管理用户</strong>，用户账号和信息存储在名为mysql的mysql数据库中</p><pre><code class="lang-mysql"># 进入mysql这个数据库use mysql;# 查询user表中所有的用户账号列表select user from user;</code></pre><p>​    <strong>创建用户</strong></p><pre><code class="lang-mysql"># 新创建的用户并没有任何权限create user &lt;用户名&gt;;</code></pre><p>​    <strong>删除用户</strong></p><pre><code class="lang-mysql">delete user &lt;用户名&gt;;</code></pre><p>​    <strong>设置访问权限</strong></p><pre><code class="lang-mysql"># 查看用户账号的权限show grants for &lt;用户名&gt;;# 赋予用户访问权限grant &lt;授予的权限&gt; on &lt; 被授予访问权限的数据库或表&gt; to &lt;用户名&gt;;# 撤销赋予用户的访问权限revoke &lt;授予的权限&gt; on &lt; 被授予访问权限的数据库或表&gt; from &lt;用户名&gt;;# ex:create user ben;# 为ben用户赋予在exampleDataBase数据库的所有表的select查询权限grant select on exampleDataBase.* to ben;# 为ben用户赋予在exampleDataBase数据库的user表的select查询权限grant select on exampleDataBase.user to ben;</code></pre><p>​    <strong>grant和 revoke可在几个层次上控制访问权限：</strong></p><ul><li>整个服务器，使用 GRANT ALL 和 REVOKE ALL；</li><li>整个数据库，使用 ON database.*；</li><li>特定的表，使用 ON database.table；</li><li>特定的列；</li><li>特定的存储过程。</li></ul><div class="table-container"><table><thead><tr><th>权限</th><th>说明</th></tr></thead><tbody><tr><td>ALL</td><td>除GRANT OPTION外的所有权限</td></tr><tr><td>SELECT</td><td>使用SELECT</td></tr><tr><td>UPDATE</td><td>使用UPDATE</td></tr><tr><td>DELETE</td><td>使用DELETE</td></tr><tr><td>CREATE</td><td>使用CREATE TABLE</td></tr><tr><td>ALTER</td><td>使用ALTER TABLE</td></tr><tr><td>INSERT</td><td>使用INSERT</td></tr><tr><td>DROP</td><td>使用DROP TABLE</td></tr><tr><td>INDEX</td><td>使用CREATE INDEX和DROP INDEX</td></tr><tr><td>CREATE TEMPORARY TABLES</td><td>使用CREATE TEMPORARY TABLE</td></tr></tbody></table></div><h3 id="十四、数据类型"><a href="#十四、数据类型" class="headerlink" title="十四、数据类型"></a>十四、数据类型</h3><p>​    <strong>整型</strong>：TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。</p><p>​    <strong>浮点数类型：</strong> FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。</p><p><img src="/medias/loading.gif" data-original="https://i.loli.net/2020/11/02/zU14ZIwcWFuqRyg.jpg" alt=""></p><p>​    <strong>字符串类型：</strong>主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格。</p><p><img src="/medias/loading.gif" data-original="https://i.loli.net/2020/11/02/6dF7gqmlOCQTiLf.jpg" alt="img"></p><p>​    <strong>日期类型：</strong>主要有DATETIME和TIMESTAMP。前者能够保存从 1000 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间，它与时区无关。后者保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年，它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。</p><p><img src="/medias/loading.gif" data-original="https://i.loli.net/2020/11/02/xGy7kgbie4zdTus.jpg" alt="img"></p><h2 id="第二部分-索引"><a href="#第二部分-索引" class="headerlink" title="第二部分 索引"></a>第二部分 索引</h2><h3 id="一、查询性能优化"><a href="#一、查询性能优化" class="headerlink" title="一、查询性能优化"></a>一、<strong>查询性能优化</strong></h3><p>​    <strong>explain命令可以分析select语句。</strong></p><pre><code class="lang-mysql"># 使用 后面跟着的就是查询语句explain ...</code></pre><p>​    explain命令输出的结果有10列：<code>id、select_type、table、type、possible_keys、key、key_len、ref、rows、extra。</code></p><p>​    <strong>各列的含义如下：</strong></p><ul><li>id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</li><li>select_type: SELECT 查询的类型.</li><li>table: 查询的是哪个表</li><li>partitions: 匹配的分区</li><li>type: join 类型</li><li>possible_keys: 此次查询中可能选用的索引</li><li>key: 此次查询中确切使用到的索引.</li><li>ref: 哪个字段或常数与 key 一起被使用</li><li>rows: 显示此查询一共扫描了多少行. 这个是一个估计值.</li><li>filtered: 表示此查询条件所过滤的数据的百分比</li><li>extra: 额外的信息</li></ul><p>​    <strong>select_type</strong>，表示了查询的类型, 它的常用取值有:</p><ul><li>SIMPLE, 表示此查询不包含 UNION 查询或子查询</li><li>PRIMARY, 表示此查询是最外层的查询</li><li>UNION, 表示此查询是 UNION 的第二或随后的查询</li><li>DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询</li><li>UNION RESULT, UNION 的结果</li><li>SUBQUERY, 子查询中的第一个 SELECT</li><li>DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.</li></ul><p>​    <strong>table</strong>，就是要查询的表</p><p>​    <strong>possible_keys</strong>，就是可选择的索引。表示 MySQL 在查询时, 能够使用到的索引</p><p>​    <strong>key</strong>，就是查询语句真正用到的索引</p><p>​    <strong>type</strong>，指明了MySQL决定如何查找表中符合条件的行</p><ul><li>ALL：表示全表扫描, 这个类型的查询是性能最差的查询之一。</li><li>index：表示全索引扫描，index 类型则仅仅扫描所有的索引, 而不扫描数据。通常出现在:所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据就是覆盖索引</li><li>range：表示使用索引范围查询，通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中</li><li>ref：一种索引访问，也称索引查找，它返回所有匹配某个单个值的行。此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了最左前缀规则索引的查询。</li><li>eq_ref：使用这种索引查找，最多只返回一条符合条件的记录。在使用唯一性索引或主键查找时会出现该值，非常高效。</li><li>const: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.</li><li>system: 表中只有一条数据. 这个类型是特殊的 <code>const</code> 类型.</li><li>NULL：在执行阶段不需要访问表。</li></ul><p>​    <strong>key_len</strong>，这一列显示了在索引里使用的字节数。</p><p>​    <strong>rows</strong>，这一列显示了估计要找到所需的行而要读取的行数，这个值是估计值。这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好。</p><p>​    <strong>extra</strong>，这一列显示额外的信息。</p><ul><li>Using filesort：当 Extra 中有 <code>Using filesort</code> 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 <code>Using filesort</code>, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.</li><li>Using index：使用覆盖索引，表示查询索引就可查到所需数据，不用扫描表数据文件，往往说明性能不错。</li><li>Using temporary：在查询结果排序时会使用一个临时表，一般出现于排序、分组和多表 join 的情况，查询效率不高，建议优化。</li><li>Using Where：在存储引擎检索行后再进行过滤，使用了where从句来限制哪些行将与下一张表匹配或者是返回给用户。</li></ul><h3 id="二、索引类型"><a href="#二、索引类型" class="headerlink" title="二、索引类型"></a>二、索引类型</h3><p>​    <strong>索引是表的目录</strong>，是数据库中专门用于帮助用户快速查询数据的一种数据结构。类似于字典中的目录，查找字典内容时可以根据目录查找到数据的存放位置，以此快速定位查询数据。对于索引，会保存在额外的文件中。</p><p>​    <strong>1.B-Tree索引</strong>，它可以加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是在索引树中的根节点开始进行搜索。<code>B-Tree</code>对索引列是顺序组织存储的。它是<code>mysql</code>大部分存储引擎的默认索引类型。</p><p>​    <strong>2.哈希索引</strong>，基于哈希表来实现。在<code>mysql</code>中只有Memory引擎显示支持哈希索引。哈希索引能以 O(1) 时间进行查找，但是也有很多限制。</p><ul><li>无法进行排序和分组</li><li>不支持部分索引列匹配查找。因为哈希索引是使用索引列的全部内容来计算哈希值的。例如在数据列(A,B)中建立哈希索引，如果查询只有数据列A或者B则无法使用该索引。</li><li>只支持精确查找，无法用于部分查找和范围查找。</li></ul><p>​    <strong>InnoDB 存储引擎</strong>有一个特殊的功能叫<code>“自适应哈希索引“</code>，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p><p>​    <strong>3.全文索引</strong>，MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE。全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p><p>​    <strong>4.空间数据索引</strong>，MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。必须使用 GIS 相关的函数来维护数据。</p><h3 id="三、索引分类"><a href="#三、索引分类" class="headerlink" title="三、索引分类"></a>三、索引分类</h3><p>​    <strong>1.聚簇索引</strong>，是一种数据结构，它的数据行其实放在了索引的叶子页中。叶子页包含了行的全部数据，但是节点页只包含了索引列。<code>Innodb存储引擎</code>是索引组织表，即表中数据按照主键顺序存放。它通过主键来聚集数据，所以每张表只能有一个<code>聚簇索引</code>。我们在建表的时候会定义一个主键，这个主键其实就是聚簇索引了，所以并不需要为主键再添加一个索引了。</p><p>​    <strong>聚簇索引的优点：</strong></p><ul><li>数据访问更快</li><li>对于主键的排序查找和范围查找速度很快</li></ul><p>​    <strong>2.辅助索引</strong>，叶子节点并不包含行记录的全部数据。叶子节点除了包含键值以外，每个叶子节点的索引行还包含了一个书签。这个书签用来告诉<code>Innodb存储引擎</code>哪里可以找到与索引相对应的行数据，则这个书签就是相应行数据的聚集索引键就是主键。这个过程就是当搜索索引列时，会在辅助索引上检索，检索成功后会到达其叶子节点获取对应的主键，使用主键再聚簇索引上再进行对应的检索操，这就是所谓的<strong>回表查询</strong>。辅助索引可以有很多个，而聚簇索引只能由一个。</p><p>​    <strong>3.覆盖索引</strong>，即从辅助索引中就可以得到查询的记录，而不需要查询聚簇索引中的记录，就是不需要所谓的回表查询，这样和原来相比既减少了大量的IO操作又提升了速度。覆盖索引必须让辅助索引存储索引列的值。</p><p>​    <strong>4.联合索引</strong>，指对表中的多个列进行索引，就是一个索引中有很多的数据行。例如联合索引(A,B,C)就是建立了(A)，(A,B)，(A,B,C)三个索引。联合索引的好处是对第二个数据行进行了排序处理。例如索引(A,B)该联合索引语句对B这个数据行进行了排序处理。</p><p>​    <strong>5.前缀索引</strong>，对于BLOB和TEXT或者较长的varchar类型的列必须使用前缀索引，只索引开始的部分字符。选择的字符要足够长的前缀来保证较高的选择性，同时也不能太长，就是说选择的字符可以代表整个列。</p><pre><code class="lang-mysql">选择字符数目的一个办法是计算完整列的选择性，并使前缀的选择性接近于完整列的选择性# 假设表user的name字段是一个较长的varchar类型# 完整列的选择性select count(distinct name)/count(*) from suer;# 更换字符的数目来计算完整性select count(distinct left(name,3))/count(*) as sel3,    count(distinct left(name,4))/count(*) as sel4,    count(distinct left(name,5))/count(*) as sel5,    count(distinct left(name,6))/count(*) as sel6,    count(distinct left(name,7))/count(*) as sel7 from user;# 哪个字符数目的选择性接近于完整列的选择性就可以选择整个字符数目# 创建前缀索引 ?代表的是字符数目create index namekey on user(name(?))</code></pre><p>​    <strong>6.多列索引</strong>，将搜索很多个列都建立单独的索引，就是多个单列索引(辅助索引)。Mysql在5.0后引入了一种”索引合并”的策略。这种策略分为三种：or条件的联合、and条件的相交、组合前两种情况的联合和相交。索引合并看似是一种优化的结果但尽量不要多用，可以建立联合索引来代替多个单列索引。</p><h3 id="四、索引操作"><a href="#四、索引操作" class="headerlink" title="四、索引操作"></a>四、索引操作</h3><p>​    <strong>普通索引</strong></p><pre><code class="lang-mysql"># 建表中index(&lt;数据行&gt;,...);# 建表后 如果列名是char或者varchar类型,length可以小于字段实际长度；如果是BLOB或者TEXT类型，必须指定长度用于前缀索引create index &lt;索引名&gt; on &lt;表名&gt;(&lt;列名&gt;(长度),...);# 删除索引drop index &lt;索引名&gt; on &lt;表名&gt;;# 修改表结构(添加索引)alter table &lt;表名&gt; add index &lt;索引名&gt;(&lt;列名&gt;);# 删除索引alter table &lt;表名&gt; drop index &lt;索引名&gt;;</code></pre><p>​    <strong>唯一索引</strong></p><pre><code class="lang-mysql"># 建表中unique index(&lt;数据行&gt;,...);# 建表后 如果列名是char或者varchar类型,length可以小于字段实际长度；如果是BLOB或者TEXT类型，必须指定长度用于前缀索引create unique index &lt;索引名&gt; on &lt;表名&gt;(&lt;列名&gt;(长度),...);# 删除索引drop index &lt;索引名&gt; on &lt;表名&gt;;# 修改表结构(添加索引)alter table &lt;表名&gt; add unique index &lt;索引名&gt;(&lt;列名&gt;);# 删除索引alter table &lt;表名&gt; drop index &lt;索引名&gt;;</code></pre><p>​    <strong>查看表中的索引</strong></p><pre><code class="lang-mysql">show index from &lt;表名&gt;;</code></pre><p>​    <strong>普通索引和唯一索引的区别</strong></p><ul><li>从查询操作方面，普通索引会查找到第一个满足条件的记录后，继续向后遍历，直到第一个不满足条件的记录。而唯一索引会查找到第一个满足条件的记录后，直接停止继续检索。</li><li>从更新操作方面，普通索引将数据页从磁盘读入内存，更新数据页。而唯一索引将数据页从磁盘读入内存，判断是否唯一，再更新数据页。</li></ul><p>​     <strong>适合建立索引的字段</strong></p><ul><li>具有高选择性的字段就适合建索引，比如gender性别整个字段，它可取的值只有男或者女，可取值的范围很小，具有低选择性。</li><li>经常需要排序的字段，因为建立索引的时候已经排好序了。</li><li>经常用在范围内搜索的列上创建索引，因为索引已经排序了，其指定的范围是连续的。</li><li>在where子句高频出现的字段应该建立索引。</li><li>经常与其他表进行连接的表，在连接字段应该建立索引</li></ul><p>​     <strong>索引列的顺序</strong>，联合索引指对表中的多个列进行索引，这些列的顺序对于使用该索引的查询至关重要。将选择列较强的索引列放在前面。索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p><pre><code class="lang-mysql"># 假如在user表中有一个联合索引(A,B)# 计算索引A列的选择性 select count(distinct A)/count(*) from user# 计算索引B列的选择性 select count(distinct B)/count(*) from user# 假如A列的选择性比B列的选择性要高 则 联合索引就是(A,B)# 假如B列的选择性比A列的选择性要高 则 联合索引就是(B,A)</code></pre><p>​    <strong>索引的优点</strong></p><ul><li>大大减少了服务器需要扫描的数据行数。</li><li>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。</li><li>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。</li></ul><p>​    <strong>索引的缺点</strong></p><ul><li>创建索引和维护索引要耗费时间 ，耗费的时间随着数据量的增加而增加。</li><li>索引需要占物理空间 ，除了数据表占数据空间之外，每一个索引还要占一定的物理空间。</li><li>当对表中的数据进行增加、删除和修改的时候， 索引也要动态的维护 ，这样就降低了数据的维护速度。</li></ul><p>​    <strong>索引的使用条件</strong></p><ul><li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</li><li>对于中到大型的表，索引就非常有效；</li><li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li></ul><h3 id="五、索引失效"><a href="#五、索引失效" class="headerlink" title="五、索引失效"></a>五、索引失效</h3><p>​    <strong>1.查询条件包含or，可能导致索引失效</strong></p><pre><code class="lang-mysql"># 假如在user表中有两个字段A和B  A上有索引而B上没有索引# 该sql语句不会走索引的,因为B上没有索引select * from user where A=1 or B=2# 这样的语句可以用union替换select * from user where A=1 union select * from user where B=2# or连接的两个查询条件中有一个没有索引的话,引擎会放弃索引进行全表扫描</code></pre><p>​    <strong>2.索引字段是字符类型，判断的时候字符没有加引号会导致索引失效</strong></p><pre><code class="lang-mysql"># A为字符类型并加有索引 索引会失效select * from user where A=1;#  索引有效select * from user where A=&quot;1&quot;;</code></pre><p>​    <strong>3.索引列直接使用函数会导致索引失效</strong></p><pre><code class="lang-mysql"># A列加有索引 索引会失效select * from user where concat(A,&quot;d&quot;)=&quot;abcd&quot;;# 将函数置于索引列的旁边 索引有效select * from user where A=concat(&quot;abc&quot;,&quot;d&quot;);</code></pre><p>​    <strong>4.索引列参与计算会导致索引失效</strong></p><pre><code class="lang-mysql"># A列加有索引 下面的语句都会导致索引失效select * from user where A+1=21;select * from user where A-1=19;select * from user where A*2=20;select * from user where A/2=10;</code></pre><p>​    <strong>5.索引列使用is null， is not null会导致索引失效</strong></p><pre><code class="lang-mysql"># A列加有索引 下面的语句都会导致索引失效select * from user where A is null;select * from user where A is not null;</code></pre><p>​    <strong>6.like通配符可能导致索引失效</strong></p><pre><code class="lang-mysql"># A列加有索引 索引失效select * from user where A like &quot;%d&quot;;# 索引有效select * from user where A like &quot;d%&quot;;</code></pre><p>​    <strong>7.联合索引，查询时的条件列不是联合索引中的第一个列会导致索引失效</strong></p><pre><code class="lang-mysql"># 假如联合索引(A,B) 索引会失效select * from user where B=&quot;1&quot;;# 索引有效select * from user where A=&quot;2&quot;;# 索引有效select * from user where A=&quot;2&quot; and B=&quot;1&quot;;# 联合索引(A,B)就是建立了2个索引(A)和(A,B),没有B整个索引则只对B进行检索就不会使用到索引了</code></pre><p>​    <strong>8.mysql估计使用全表扫描要比使用索引快,则不使用索引</strong></p><ul><li>当表的索引被查询，会使用最好的索引，除非优化器使用全表扫描更有效。优化器优化成全表扫描取决与使用最好索引查出来的数据是否超过表的30%的数据。</li><li>不要给’性别’等增加索引。如果某个数据列里包含了均是”0/1”或“Y/N”等值，即包含着许多重复的值，就算为它建立了索引，索引效果不会太好，还可能导致全表扫描。</li></ul><h3 id="六、联合索引和多个单列索引的区别"><a href="#六、联合索引和多个单列索引的区别" class="headerlink" title="六、联合索引和多个单列索引的区别"></a>六、联合索引和多个单列索引的区别</h3><p>​    <strong>1.联合索引测试</strong></p><pre><code class="lang-mysql"># 建表  学生表 并为其插入数据create table student(    id int auto_increment,    name varchar(10) null,    age int null,    address varchar(20) null,    mobile varchar(15) null,    primary key(id))engine=innodb# 建立联合索引create index unionKey on student(name,age,mobile);# 查询条件是 name 联合索引有效select * from student where name=&quot;lxt&quot;;# 查询条件是 age 联合索引失效select * from student where age=15;# 查询条件是 mobile 联合索引失效select * from student where mobile=&quot;888888&quot;;# 查询条件是 name和age 联合索引有效select * from student where name=&quot;lxt&quot; and age=15;# 查询条件是 name和mobile 联合索引有效select * from student where name=&quot;lxt&quot; and mobile=&quot;888888&quot;;# 查询条件是 age和mobile 联合索引失效select * from student where  age=15 and mobile=&quot;888888&quot;;# 查询条件是 name,age和mobile 联合索引有效select * from student where name=&quot;lxt&quot; and age=15 and mobile=&quot;888888&quot;;# 当创建联合索引(name,age,mobile)就是创建了(name),(name,age),(name,age,mobile)三个索引，想要让索引生效只能使用(name),(name,age),(name,age,mobile)三种组合了</code></pre><p>​    <strong>最左匹配原则</strong>是最左优先，以最左边的为起点任何连续的索引都能匹配上，从上面看到当查询条件是 name和mobile 联合索引还是有效的，虽然没有建立(name,mobile)这个索引但是满足了最左匹配原则，所以索引生效了。</p><p>​    <strong>2.单列索引测试</strong></p><pre><code class="lang-mysql"># 创建三个单列索引create index namekey on student(name);create index agekey on student(age);create index mobilekey on student(mobile);# 查询条件是 name,age和mobile select * from student where name=&quot;lxt&quot; and age=15 and mobile=&quot;888888&quot;;</code></pre><p>​    <strong>mysql优化器的优化策略</strong>是当多条件联合查询时，优化器会评估用哪个条件的索引效率最高从而使用哪个条件的索引。上面的sql语句使用了联合索引测试时建立的联合索引因为优化器判定这个联合索引效率更高。当删除联合索引后会发现使用了<code>namekey</code>这个索引这是因为优化器判定使用这个索引会更高。当使用上面的三个单列索引效率最高，就会使用上面的三个单列索引。</p><p>​    <strong>联合索引比多个单列索引更有优势</strong>，因为联合索引里可能包含某个单列索引。比如上面的联合索引就包含了namekey这个索引，这个索引就是重复的了。其次索引建立得越多就越占磁盘空间，在更新数据的时候速度会更慢。</p><h2 id="第三部分-锁"><a href="#第三部分-锁" class="headerlink" title="第三部分 锁"></a>第三部分 锁</h2><p>​    <img src="/medias/loading.gif" data-original="https://i.loli.net/2020/10/31/LSlRPO1AIcxTdEZ.jpg" alt=""></p><p>​    MyISAM引擎只支持表级锁，而Innodb引擎不仅支持表级锁还支持行级锁。下面都是以Innodb引擎来叙述的。</p><ul><li>表级锁，开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低。</li><li>行级锁，开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高。</li></ul><h3 id="一、表级锁"><a href="#一、表级锁" class="headerlink" title="一、表级锁"></a>一、表级锁</h3><p>​    <strong>表锁分为表读锁和表写锁。</strong></p><div class="table-container"><table><thead><tr><th>是否兼容</th><th>表读锁</th><th>表写锁</th></tr></thead><tbody><tr><td>表读锁</td><td>兼容</td><td>冲突</td></tr><tr><td>表写锁</td><td>冲突</td><td>冲突</td></tr></tbody></table></div><p>​    从上表看来：读读兼容，读写互斥，写写互斥。</p><p>​    <strong>表读锁</strong>，即用读锁锁表，会阻塞其他事务修改表数据。该线程不能修改锁定的表也不能读取其他的表。</p><pre><code class="lang-mysql"># 为&lt;表名&gt;加表读锁lock table &lt;表名&gt; read;# 解锁 commit或rollback 并不能释放表级锁,必须用unlock tables释放表锁。unlock tables;# 事务结束前，不要用unlock tables 释放表锁，因为它会隐含地提交事务# ex: 开启第一个事务1.start transaction;# 给user表加表读锁2.lock table user read;# ex: 开启第二个事务3.start transaction;# 修改user表的数据 会发现这条语句正在等待执行 因为上面的事务给user表加了表读锁4.update user set name=&quot;ljx&quot; where id=1;# 在第一个事务解锁 解锁会提交事务 该事务就无须提交了  此时会发现第二个事务的语句执行成功了5.unlock tables;# 为第二个事务提交 user表的数据语句修改了commit;</code></pre><p>​    <strong>表写锁</strong>，即用写锁锁表，会阻塞其他事务读和写。该线程不能修改锁定的表也不能读取所有的表。</p><pre><code class="lang-mysql"># 为&lt;表名&gt;加表写锁lock table &lt;表名&gt; write;# ex: 开启第一个事务1. start transaction;# 给user表加表写锁2. lock table user write;# ex: 开启第二个事务3. start transaction;# 查询数据 会发现这条语句正在等待执行 因为上面的事务给user表加了表写锁4. select * from user;# 在第一个事务解锁 解锁会提交事务 该事务就无须提交了  此时会发现第二个事务的语句执行成功了5. unlock tables;# 为第二个事务提交6. commit;# 将第4步的查询语句更换为更新语句也是一样的</code></pre><h3 id="二、行级锁"><a href="#二、行级锁" class="headerlink" title="二、行级锁"></a>二、行级锁</h3><p>​    <strong>Innodb实现了两种标准的行级锁。</strong></p><ul><li>共享锁(S)，允许事务读一行数据，阻止其他事务获得该行的排他锁，事务也可以修改这一行数据。</li><li>排他锁(X)，允许事务删除或更新一行数据，阻止其他事务取得相同该行的共享锁和排他锁</li></ul><p>​    <strong>为了允许行锁和表锁共存</strong>，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是<strong>表锁</strong>。</p><ul><li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。</li><li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。</li></ul><p>​    <strong>为什么要加这两种意向锁呢？这两种意向锁存在的意义是什么呢？</strong>假如事务A锁定了表中的一行，这一行只能读不能写。之后事务B申请了整个表的写锁，如果事务B申请成功则它可以修改表中的任意一行，但是这就与事务A发生了冲突。意向锁的存在就是为了解决这种冲突的。<strong>申请意向锁是 Innodb 自动加的， 不需用户干预。</strong></p><div class="table-container"><table><thead><tr><th>是否兼容</th><th>共享锁</th><th>排他锁</th></tr></thead><tbody><tr><td>共享锁</td><td>兼容</td><td>冲突</td></tr><tr><td>排他锁</td><td>冲突</td><td>冲突</td></tr></tbody></table></div><p>​    由于意向锁IS,IX是表锁，它们不会与行级的X,S锁发生冲突，只会与表级锁发送冲突。</p><div class="table-container"><table><thead><tr><th>是否兼容</th><th>意向共享锁</th><th>意向排他锁</th><th>表读锁</th><th>表写锁</th></tr></thead><tbody><tr><td>意向共享锁</td><td>兼容</td><td>兼容</td><td>兼容</td><td>冲突</td></tr><tr><td>意向排他锁</td><td>兼容</td><td>兼容</td><td>冲突</td><td>冲突</td></tr></tbody></table></div><p>​    当事务A申请表中某一行的行级共享锁，就会先申请意向共享锁。而当事务B申请表的表写锁时，表写锁与意向共享锁冲突，则申请不成功。</p><p>​    <strong>Innodb加行级锁方法</strong>，对于update、delete和insert语句，innodb引擎会自动给数据集加行家排他锁。对于普通的select语句，innodb不会加任何的锁，但可以显式地加锁。</p><pre><code class="lang-mysql"># 只有在事务中才可以进行使用# 给检索的数据加共享锁 允许其他事务读取该行数据,但不能获得排他锁就是不能修改select ...  lock in share mode;# 给检索的数据加排他锁 允许其他事务读取该行数据,但不能获得排他锁和共享锁select ... for update;</code></pre><p>​    <strong>行级锁只有在执行commit和rollback的时候才会释放，并且所有的锁同时释放。</strong></p><p>​    <strong>Innodb行锁实现方式</strong></p><ul><li>InnodB 行锁是通过给索引上d的索引项加锁d来实现的。InnodB 这种行锁实现特点意味着：只有通过索引条件检索数据，InnodB 才使用行级锁，否则，InnodB 将使用表锁！</li><li>不论是使用主键索引、唯一索引或普通索引，InnodB 都会使用行锁来对数据加锁。</li><li>只有执行计划真正使用了索引，才能使用行锁：即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnodB 将使用表锁，而不是行锁。</li></ul><p>​    <strong>共享锁</strong></p><pre><code class="lang-mysql"># 实例表user id是主键 在innodb里主键就是聚簇索引# ex 开启第一个事务1. start transaction;# 通过主键来检索数据 并为该行加共享锁2. select * from user where id=1 lock in share mode;# ex 开启第二个事务3. start transaction;# 可以检索这一行的数据4. select * from user where id=1;# 更新这一行的数据 会发现正在等待执行 因为加了共享锁就不能再为该行加排他锁了,update语句自动为该行加了排他锁 但是可以更新其他行的数据5. update user set name=&quot;ljx&quot; where id=1;# 在第一个事务解锁 会发现在第二个事务中的update语句执行成功了6. commit;# 为第二个事务提交 会发现user表更新成功7. commit;</code></pre><p>​    <strong>排他锁</strong></p><pre><code class="lang-mysql"># 实例表user id是主键 在innodb里主键就是聚簇索引# ex 开启第一个事务1. start transaction;# 通过主键来检索数据 并为该行加排他锁2. select * from user where id=1 for update;# ex 开启第二个事务3. start transaction;# 可以检索这一行的数据 因为select语句并没有加任何锁4. select * from user where id=1;# 更新这一行的数据 会发现正在等待执行 因为加了排他锁就不能再为该行加排他锁了 但是可以更新其他行的数据5. update user set name=&quot;ljx&quot; where id=1;# 在第一个事务解锁 会发现在第二个事务中的update语句执行成功了6. commit;# 为第二个事务提交 会发现user表更新成功7. commit;# 将第5句的更新语句修改为 select * from user where id=1 lock in share mode; 也会一样的</code></pre><p>​    <strong>测试当where子句的字段不是索引会如何？</strong></p><pre><code class="lang-mysql"># 实例表user name字段没有加索引# ex 开启第一个事务1. start transaction;# 为检索的该行加排他锁2. select * from user where name=&quot;lxt&quot; for update;# ex 开启第二个事务3. start transaction;# 可以检索数据4. select * from user where name=&quot;lxt&quot;;# 更新这一行的数据 会发现正在等待执行 该行并没有加排他锁 很显然就是锁表了,加的应该是表读锁因为可以检索数据但不能修改数据5.update user set name=&quot;lxt&quot; where name=&quot;ljx&quot;;# 在第一个事务解锁 会发现在第二个事务中的update语句执行成功了6. commit;# 为第二个事务提交 会发现user表更新成功7. commit;</code></pre><p>​    当where条件不是索引时，如果加了排他锁，对这个表其它行记录也不能再加排他锁了，这明显就是锁住了整个表。而如果条件是索引字段，则它只会对where条件指定的行数据加锁，另一个事务可以对其它行数据加锁。</p><h3 id="三、乐观锁和悲观锁"><a href="#三、乐观锁和悲观锁" class="headerlink" title="三、乐观锁和悲观锁"></a>三、乐观锁和悲观锁</h3><p>​    <strong>乐观锁</strong>，对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁（这使得多个任务可以并行的对数据进行操作），只有到数据提交的时候才通过一种机制来验证数据是否存在冲突。具体实现是，表中有一个版本字段，第一次读的时候，获取到这个字段。处理完业务逻辑开始更新的时候，需要再次查看该字段的值是否和第一次的一样。如果一样更新，反之拒绝。</p><p>​    <strong>乐观锁实现形式：</strong></p><div class="table-container"><table><thead><tr><th>id</th><th>name</th><th>version</th></tr></thead><tbody><tr><td>1</td><td>lxt</td><td>1</td></tr></tbody></table></div><pre><code class="lang-mysql"># 事务1 查询出记录出来,同时会有一个version=1字段select * from &lt;表名&gt; where id=1;# 事务2 查询出记录出来,同时会有一个version=1字段select * from &lt;表名&gt; where id=1;# 事务1 更新name为ljx并修改version字段update &lt;表名&gt; set name=&quot;ljx&quot; and version=version+1 where id=1 and version=1;# 事务2 更新name为wy并修改version字段update &lt;表名&gt; set name=&quot;ljx&quot; and version=version+1 where id=1 and version=1;# 事务2的更新语句会更新失败,因为第一次拿到的version为1而经过事务2更新后version已经变为2，实际存在的version和第一次拿到的version不一样则更新失败</code></pre><p>​    <strong>悲观锁</strong>，基于一种悲观的态度类来防止一切数据冲突，它是以一种预防的姿态在修改数据之前把数据锁住，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁，然后才可以对数据进行操作，一般数据库本身锁的机制都是基于悲观锁的机制实现的。</p><p>​    <strong>悲观锁实现形式</strong></p><pre><code class="lang-mysql"># 为检索的该行加上排他锁,其他事务不能修改该行但是可以读取该行的数据select ... for update;</code></pre><h3 id="四、间隙锁"><a href="#四、间隙锁" class="headerlink" title="四、间隙锁"></a>四、间隙锁</h3><p>​    当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。</p><p>​    值得注意的是：间隙锁只会在 <code>Repeatable read</code>隔离级别下使用</p><p>​    <strong>InnoDB使用间隙锁的目的：</strong></p><ul><li>防止幻读，以满足相关隔离级别的要求</li><li>满足恢复和复制的需要</li></ul><h3 id="五、死锁"><a href="#五、死锁" class="headerlink" title="五、死锁"></a>五、死锁</h3><p>​    <strong>死锁产生：</strong></p><ul><li>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。</li><li>当事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时也可能会产生死锁。</li><li>锁的行为和顺序和存储引擎相关。以同样的顺序执行语句，有些存储引擎会产生死锁有些不会——死锁有双重原因：真正的数据冲突；存储引擎的实现方式。</li></ul><p>​    <strong>死锁恢复：</strong>死锁发生以后，只有部分或完全回滚其中一个事务，才能打破死锁，InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。所以事务型应用程序在设计时必须考虑如何处理死锁，多数情况下只需要重新执行因死锁回滚的事务即可。</p><p>​    <strong>Innodb避免死锁：</strong></p><ul><li>尽量使用较低的隔离级别</li><li>不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会</li><li>大事务拆小。大事务更倾向于死锁，如果业务允许，将大事务拆小。</li><li>精心设计索引， 并尽量使用索引访问数据， 使加锁更精确， 从而减少锁冲突的机会</li></ul><h3 id="六、封锁协议"><a href="#六、封锁协议" class="headerlink" title="六、封锁协议"></a>六、封锁协议</h3><p>​    <strong>一级封锁协议</strong>，事务T在修改数据R之前必须先对其加排他z锁，直到事务结束后才可以释放。</p><p>​    <strong>二级封锁协议</strong>，在一级封锁协议基础上增加了事务T在读取数据R之前必须对它加共享锁，读完后即可释放。</p><p>​    <strong>三级封锁协议</strong>，在一级封锁协议基础上增加了事务T在读取数据R之前必须对它加共享锁直到事务结束才可以释放。</p><p>​    <strong>两段锁协议</strong>，含义是事务分为两个阶段。第一个阶段是获得封锁，在这个阶段中事务可以申请任何数据项的任何类型的锁，但是不能释放任何锁；第二个阶段是释放封锁，在这个阶段，事务可以释放任何数据项的任何类型的锁，但是不能再申请任何锁。InnoDB在事务执行过程中，使用两阶段锁协议，随时都可以执行锁定，InnodB会根据隔离级别在需要的时候自动加锁。</p><h2 id="第四部分-事务"><a href="#第四部分-事务" class="headerlink" title="第四部分 事务"></a>第四部分 事务</h2><p>​    <strong>事务可由一条非常简单的SQL语句组成，也可以由一组复杂的SQL语句组成。事务是访问并更新数据库中各自数据项的一个程序执行单元。在事务的操作中，要么都做，要么都不做，这就是事务的目的。</strong></p><p>​    <strong>事务的四大特性ACID</strong></p><ul><li>原子性(A)：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部都执行，要么都不执行。</li><li>一致性(C)：指在事务开始之前和事务结束以后，数据不会被破坏。</li><li>隔离性(I)：一个事务不应该被其他事务干扰。即一个事务所做的修改在最终提交之前，对其他事务是不可见的。</li><li>持久性(D)：一旦事务提交，则对其做出的修改将永远保存在数据库中。即使系统发送崩溃，事务执行的结果也不能丢。</li></ul><h3 id="一、事务并发出现的问题"><a href="#一、事务并发出现的问题" class="headerlink" title="一、事务并发出现的问题"></a>一、事务并发出现的问题</h3><pre><code> **1.脏读（dirty read）**</code></pre><div class="table-container"><table><thead><tr><th>时间</th><th>转账事务A</th><th>取款事务B</th></tr></thead><tbody><tr><td>T1</td><td></td><td>开始事务</td></tr><tr><td>T2</td><td>开始事务</td><td></td></tr><tr><td>T3</td><td></td><td>查询账户存款为1000元</td></tr><tr><td>T4</td><td></td><td>取出500元，把存款改为500元</td></tr><tr><td>T5</td><td>查询账户存款为500元(脏读)</td><td></td></tr><tr><td>T6</td><td></td><td>撤销事务，余款恢复为1000元</td></tr><tr><td>T7</td><td>汇入100元，把余款改为600元</td><td></td></tr><tr><td>T8</td><td>提交事务</td></tr></tbody></table></div><p>​    在这个场景中事务A读到了事务B尚未提交的数据，这就是<strong>脏读</strong>。</p><p>​    <strong>2.不可重复度（unrepeatable read）</strong></p><div class="table-container"><table><thead><tr><th>时间</th><th>转账事务A</th><th>取款事务B</th></tr></thead><tbody><tr><td>T1</td><td></td><td>开始事务</td></tr><tr><td>T2</td><td>开始事务</td><td></td></tr><tr><td>T3</td><td></td><td>查询账户存款为1000元</td></tr><tr><td>T4</td><td>查询账户存款为1000元</td><td></td></tr><tr><td>T5</td><td></td><td>取出100元，把存款改为900元</td></tr><tr><td>T6</td><td></td><td>提交事务</td></tr><tr><td>T7</td><td>查询账户存款为900元(和T4查询的不一致)</td></tr></tbody></table></div><p>​    在事务A的范围内，两个相同的查询，读取同一条记录却返回了不同的数据，这就是<strong>不可重复读</strong>。</p><p>​    <strong>3.幻读</strong></p><div class="table-container"><table><thead><tr><th>时间</th><th>转账事务A</th><th>取款事务B</th></tr></thead><tbody><tr><td>T1</td><td></td><td>开始事务</td></tr><tr><td>T2</td><td>开始事务</td><td></td></tr><tr><td>T3</td><td>查询用户存款大于10000的有3个</td><td></td></tr><tr><td>T4</td><td></td><td>新增一个存款账户，存款为20000</td></tr><tr><td>T5</td><td></td><td>提交事务</td></tr><tr><td>T6</td><td>再次统计用户存款大于10000的有4个(幻读)</td></tr></tbody></table></div><p>​    事务A查询一个范围的结果集，另一个并发事务B往这个范围中插入/删除了数据，并静悄悄地提交，然后事务A再次查询相同的范围，两次读取得到的结果集不一样了，这就是<strong>幻读</strong>。</p><p>​    <strong>幻读和不可重复读是两个容易混淆的概念</strong>。幻读是指读到了其他已经提交的事务的新增数据，而不可重复读是指读到了已经提交事务的更改数据(更改或删除)。解决不可重复读可以将操作的数据添加行级锁，而解决幻读可以将操作的表添加表级锁。</p><h3 id="二、事务的四大隔离级别"><a href="#二、事务的四大隔离级别" class="headerlink" title="二、事务的四大隔离级别"></a>二、事务的四大隔离级别</h3><pre><code class="lang-mysql"># 示例表usercreate table user(    # int类型 自增健    id int auto_increment ,    # 变长字符串类型 可为空     name varchar(20) null ,    # 设置主键为id 主键不可为空    primary key(id))engine=innodb;# 插入数据insert into user(id,name) values(1,&quot;lxt&quot;);insert into user(id,name) values(2,&quot;ljx&quot;);insert into user(id,name) values(3,&quot;wy&quot;);insert into user(id,name) values(4,&quot;xgh&quot;);</code></pre><p>​    <strong>1.读未提交（Read Uncommitted）</strong></p><pre><code class="lang-mysql"># 打开第一个窗口 将事务隔离级别设置为 read uncommittedset session transaction isolation level read uncommitted;# 开启事务start transaction;# 检索数据select * from user where id=1;# 数据的name为lxt# 打开第二个窗口 将事务隔离级别也设置为 read uncommittedset session transaction isolation level read uncommitted;# 开启事务start transaction;# 更新数据update user set name=&quot;ljx&quot; where id=1;# 再重新打开第一个窗口  会发现name为ljxselect * from user where id=1;</code></pre><p>​    在读未提交级别中，一个事务可以读到其他事务未提交的数据，即存在<strong>脏读</strong>的问题。读未提交级别是最低的一种级别。</p><p>​    <strong>2.读已提交（READ COMMITTED）</strong></p><pre><code class="lang-mysql"># 打开第一个窗口 将事务隔离级别设置为 read committedset session transaction isolation level read committed;# 开启事务start transaction;# 检索数据select * from user where id=1;# 数据的name为ljx# 打开第二个窗口 将事务隔离级别设置为 read committedset session transaction isolation level read committed;# 开启事务start transaction;# 更新数据update user set name=&quot;lxt&quot; where id=1;# 再重新打开第一个窗口  会发现name为ljx 没有改变select * from user where id=1;# 再重新打开第二个窗口  提交事务commit;# 再重新打开第一个窗口  会发现name为lxt 发生了改变select * from user where id=1;</code></pre><p>​    在读已提交级别中已经不会出现<strong>脏读</strong>问题了，当前事务只能读到其他事务提交的数据。但是在第一个窗口的事务中相同的sql查询读到的数据是不相同的，出现了<strong>不可重复读</strong>的问题。</p><p>​    <strong>3.可重复读（Repeatable Read）</strong></p><pre><code class="lang-mysql"># 打开第一个窗口 将事务隔离级别设置为 repeatable readset session transaction isolation level repeatable read;# 开启事务start transaction;# 检索数据select * from user where id=1;# 数据的name为lxt# 打开第二个窗口 将事务隔离级别设置为 repeatable readset session transaction isolation level repeatable read;# 开启事务start transaction;# 更新数据update user set name=&quot;ljx&quot; where id=1;# 再重新打开第一个窗口  会发现name为lxt 没有改变select * from user where id=1;# 再重新打开第二个窗口  提交事务commit;# 再重新打开第一个窗口  会发现name为lxt 依旧没有发生改变select * from user where id=1;# 再重新打开第一个窗口  提交事务commit;# 再重新打开第一个窗口  会发现name为ljx 发生了改变select * from user where id=1;</code></pre><p>​    在可重复读级别中就不会存在<strong>不可重复读</strong>的问题，当前事务不同时间内读取相同的sql查询，得到的数据是相同的。</p><pre><code class="lang-mysql"># 打开第一个窗口 将事务隔离级别设置为 repeatable readset session transaction isolation level repeatable read;# 开启事务start transaction;# 检索数据select * from user where id&gt;2;# 会发现有两个数据行# 打开第二个窗口 将事务隔离级别设置为 repeatable readset session transaction isolation level repeatable read;# 开启事务start transaction;# 插入数据insert into user(id,name) values(5,&quot;fsh&quot;);# 再重新打开第一个窗口  会发现有两个数据行 数据没有改变select * from user where id&gt;2;# 再重新打开第二个窗口  提交事务commit;# 再重新打开第一个窗口  会发现有两个数据行 数据依旧没有发生改变select * from user where id&gt;2;# 再重新打开第一个窗口  提交事务commit;# 再重新打开第一个窗口  会发现数据发生了改变，变成了3个select * from user where id&gt;2;</code></pre><p>​    上面的例子中在可重复读级别中并没有出现<strong>幻读</strong>的问题。第二个窗口事务插入数据并提交事务的前后，第一个窗口事务读取的数据集并没有发生改变。</p><pre><code class="lang-mysql"># 打开第一个窗口 将事务隔离级别设置为 repeatable readset session transaction isolation level repeatable read;# 开启事务start transaction;# 检索数据select * from user where id&gt;2;# 会发现有两个数据行# 打开第二个窗口 将事务隔离级别设置为 repeatable readset session transaction isolation level repeatable read;# 开启事务start transaction;# 插入数据insert into user(id,name) values(5,&quot;fsh&quot;);# 再重新打开第一个窗口  会发现有两个数据行 数据没有改变select * from user where id&gt;2;# 再重新打开第二个窗口  提交事务commit;# 再重新打开第一个窗口  会发现有两个数据行 数据依旧没有发生改变select * from user where id&gt;2;# 在第一个窗口 更新第二个窗口刚插入的数据update user set name=&quot;ljk&quot; where id=5;# 再重新打开第一个窗口  会发现有三个数据行 数据发生了改变select * from user where id&gt;2;# 再重新打开第一个窗口  提交事务commit;</code></pre><p>​    上面的例子中在可重复读级别中出现了<strong>幻读</strong>的问题。该例子和上面的例子相比就是多了最后更新刚插入的数据这条语句就导致了幻读的问题。同一个事务，相同的sql语句，查出的结果集不同，这符合<strong>幻读</strong>的定义。</p><p>​    <strong>4.串行化（Serializable）</strong></p><p>​    <strong>前面的三种数据库隔离级别或多或少都会有一定的问题。</strong></p><pre><code class="lang-mysql"># 打开第一个窗口 将事务隔离级别设置为 serializableset session transaction isolation level serializable;# 开启事务start transaction;# 检索数据select * from user where id&gt;2;# 会发现有两个数据行# 打开第二个窗口 将事务隔离级别设置为 serializableset session transaction isolation level serializable;# 开启事务start transaction;# 插入数据 会发现这条语句正在等待执行 insert into user(id,name) values(5,&quot;fsh&quot;);# 打开第一个窗口 提交事务 会发现第二个窗口的插入语句执行成功commit;# 打开第二个窗口 提交事务 commit;</code></pre><p>​    在串行化级别中不会再存在<strong>幻读</strong>的问题了。第二个窗口中事务的写操作要等第一个窗口中事务的读操作结束才可以继续执行。这是数据库隔离级别最严格的一种。</p><p>​    <strong>查看mysql的默认事务隔离级别</strong></p><pre><code class="lang-mysql"># 第一个是mysql系统的默认事务隔离级别# 第二个是当前对话的默认事务隔离级别# mysql版本为8select @@global.transaction_isolation,@@transaction_isolation;</code></pre><h2 id="第四部分-关系数据库设计理论"><a href="#第四部分-关系数据库设计理论" class="headerlink" title="第四部分 关系数据库设计理论"></a>第四部分 关系数据库设计理论</h2><h3 id="一、函数依赖和码"><a href="#一、函数依赖和码" class="headerlink" title="一、函数依赖和码"></a>一、函数依赖和码</h3><p>​    不存在两个元组中在X上的属性值相同，而在Y上的属性值不相同则称<strong>X函数决定Y</strong>或<strong>Y函数依赖于X</strong>，记作X→ Y。通俗来说当X相同Y一定相同，当Y相同X不一定相同。例如学号决定姓名。</p><p>​    如果X→ Y，并且对于X的任何一个真子集X‘，都有X’不决定Y，则称Y对X<strong>完全函数依赖</strong>。</p><p>​    如果X→ Y，如果能找到X的任何一个真子集X’，使得X‘→ Y，则称Y对X<strong>部分函数依赖</strong>。</p><p>​    如果X→ Y，Y→ Z则称X→ Z，即Z对X<strong>传递函数依赖</strong>。</p><p>​    设K为R<U,F>中的属性和属性组合，若K对U完全函数依赖，则K为R的<strong>候选码</strong>。</p><p>​    <strong>求候选码的方法：</strong></p><ul><li>如果有属性不在函数依赖集中出现，那么它必须包含在候选码中</li><li>如果有属性只在函数依赖集中任何函数依赖的右边出现，那么它不包含在候选码中</li><li>如果有属性只在函数依赖集的左边出现，则该属性一定包含在候选码中</li><li>其他属性求属性闭包，如果该属性的闭包等于全部的数据，则该属性为候选码</li></ul><p>​    <strong>计算属性的闭包：</strong></p><ul><li>闭包就是由一个属性直接或间接推导出的所有属性的集合</li><li>设有关系模式R(U,F)，U={A,B,C}，F={A→B,B → C}，则A的闭包为{A,B,C}，B的闭包为{B,C}，C的闭包为{C}</li></ul><p>​    包含在任何一个候选码的属性称为<strong>主属性</strong>，而不包含在任何候选码中的属性称为<strong>非主属性</strong>。</p><h3 id="二、范式"><a href="#二、范式" class="headerlink" title="二、范式"></a>二、范式</h3><p>​    <strong>第一范式（1NF）</strong></p><ul><li>每一个数据项都是不可再分的数据项</li></ul><p>​    <strong>第二范式（2NF）</strong></p><ul><li>满足第一范式，并且每一个非主属性完全函数依赖于任何一个候选码。</li></ul><p>​    <strong>第二范式的应用例子</strong></p><p>​    学生关系模式为 (Sno,Sdept,Sloc,Cno,Grade)，Sno为学号 ，Sdept为系别， Sloc为学生的住处并且每个系的学生都住一起 ，Cno为学生的课程号， Grade为学生的课程成绩。则函数依赖为</p><ul><li>Sno-&gt;Sdept</li><li>(Sno,Cno)-&gt;Grade</li><li>Sdept-&gt;Sloc</li><li>因为Sno-&gt;Sdept，Sdept-&gt;Sloc则Sno-&gt;Sloc</li></ul><p>​    Sno和Cno只在依赖的左边存在，而Sloc和Grade只在依赖的右边存在，则Sno和Cno为候选码，Sloc和Grade不是候选码。Sdept的闭包为(Sdept,Sloc),并不是全部的数据集,则不是候选码。</p><p>​    Sdept对(Sno,Cno)部分函数依赖，Sloc对(Sno,Cno)部分函数依赖，Grade对(Sno,Cno)完全函数依赖，则该模式不满足第二范式。</p><p>​    <strong>解决方案</strong>：将部分函数依赖和完全函数依赖分隔开，就是分解为两个关系模式。例子中可以分解为(Sno,Sdept,Sloc)和(Sno,Cno,Grade)。</p><p>​    <strong>第三范式（3NF）</strong></p><ul><li>满足第一范式，并且非主属性没有传递函数依赖于候选码</li></ul><p>​    <strong>第三范式的应用例子</strong></p><p>​    在第二范式分解后有一个关系模式为(Sno,Sdept,Sloc)，函数依赖为</p><ul><li>Sno-&gt;Sdept</li><li>Sdept-&gt;Sloc</li></ul><p>​    非主属性Sloc传递函数依赖于候选码Sno，则该关系模式不满足于第三范式。</p><p>​    <strong>解决方案：</strong> 将这两个函数依赖分解为两个关系模式，就是(Sno,Sdept)和(Sdept,Sloc)。</p><p>​    <strong>范式的优点</strong></p><ul><li>范式化的更新操作更快</li><li>范式化的表很小，可以更好地放在内存中</li><li>只有很少或者没有重复的数据</li></ul><p>​    <strong>范式的缺点</strong></p><ul><li>一些复杂的查询语句通常需要很多关联</li></ul><h3 id="三、反范式"><a href="#三、反范式" class="headerlink" title="三、反范式"></a>三、反范式</h3><p>​    <strong>反范式</strong>就是将所有的数据都存在了一个表中。</p><p>​    <strong>反范式的优点</strong></p><ul><li>避免关联</li></ul><p>​    <strong>反范式的缺点</strong></p><ul><li>反范式化的更新操作更慢</li><li>反范式化的表很大</li><li>有很多重复的数据</li></ul><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>​    在实际操作中并没有完全的范式化和完全的反范式化。在实际中经常需要混用范式化和反范式化的。</p><h2 id="第四部分-切分"><a href="#第四部分-切分" class="headerlink" title="第四部分 切分"></a>第四部分 切分</h2><h3 id="一、水平切分"><a href="#一、水平切分" class="headerlink" title="一、水平切分"></a>一、水平切分</h3><p>​    水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。</p><p>​    当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。</p><p><img src="/medias/loading.gif" data-original="https://i.loli.net/2020/11/01/fKA5DgCZuSxYWlc.jpg" alt=""></p><p>​    </p><h3 id="二、垂直切分"><a href="#二、垂直切分" class="headerlink" title="二、垂直切分"></a>二、垂直切分</h3><p>​    垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。</p><p>​    在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。</p><p><img src="/medias/loading.gif" data-original="https://i.loli.net/2020/11/01/HMy6DrOhjP5ZcGE.jpg" alt=""></p><h3 id="三、Sharding-策略"><a href="#三、Sharding-策略" class="headerlink" title="三、Sharding 策略"></a>三、Sharding 策略</h3><ul><li>哈希取模：hash(key) % N；</li><li>范围：可以是 ID 范围也可以是时间范围；</li><li>映射表：使用单独的一个数据库来存储映射关系。</li></ul><p><strong>具体可看：</strong></p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzIwOTE2MzU4NA==&amp;mid=2247486239&amp;idx=1&amp;sn=1726a69aa0065f802cb0d0d94772a9cc&amp;chksm=97794f30a00ec6264105881f1b1da8db4987481c08e0acfc075741072c7f86dffb7a3d7c7cf1&amp;mpshare=1&amp;scene=23&amp;srcid=10168iYA2RsKP9MGroKwrbHp&amp;sharer_sharetime=1604229299747&amp;sharer_shareid=f57b3003b77f0d62d23a543c0f8a9dc0#rd" target="_blank" rel="noopener">一文快速入门分库分表（必修课）</a></li></ul><h2 id="第五部分-优化Mysql的建议"><a href="#第五部分-优化Mysql的建议" class="headerlink" title="第五部分 优化Mysql的建议"></a>第五部分 优化Mysql的建议</h2><h3 id="一、优化sql语句"><a href="#一、优化sql语句" class="headerlink" title="一、优化sql语句"></a>一、优化sql语句</h3><p><strong>1.查询SQL尽量不要使用select *，而是select具体字段。</strong></p><pre><code class="lang-mysql">select id,name from user;</code></pre><p>​    <strong>理由：</strong></p><ul><li>只取需要的字段，节省资源、减少网络开销。</li><li>select * 进行查询时，很可能就不会使用到覆盖索引了，就会造成回表查询。</li></ul><p>​    <strong>2.如果知道查询结果只有一条或者只要最大/最小一条记录，建议用limit 1</strong></p><pre><code class="lang-mysql"># 假设用户的名字不重复 则这条数据只能有一条记录select id,name from user where name=&quot;lxt&quot; limit 1;</code></pre><p>​    <strong>理由：</strong></p><ul><li><p>加上limit 1后,只要找到了对应的一条记录,就不会继续向下扫描了,效率将会大大提高。</p><p> <strong>3.避免索引失效，具体可看索引那一部分</strong></p></li></ul><p>​    <strong>理由：</strong></p><ul><li>索引失效后，查询语句会进行全表扫描，效率大大下降</li></ul><p>​    <strong>4.优化limit分页，也就是深度分页</strong></p><pre><code class="lang-mysql"># 优化前select id,name from user limit 10000,10# 方案一 返回上次查询的最大记录(偏移量)select id,name from user where id&gt;10000 limit 10;# 方案二 覆盖索引select id,name from user where id&gt;(select id from user limit 10000,10) limit 10;# 方案三 order by + 索引select id,name from user order by</code></pre><p>​    <strong>理由：</strong></p><ul><li>当偏移量最大的时候，查询效率就会越低，因为Mysql并非是跳过偏移量直接去取后面的数据，而是先把偏移量+要取的条数，然后再把前面偏移量这一段的数据抛弃掉再返回的。</li></ul><p><strong>5.Inner join 、left join、right join，优先使用Inner join，并且不管使用什么join，永远都是小表驱动大表</strong></p><p>​    <strong>理由：</strong></p><ul><li>如果inner join是等值连接，或许返回的行数比较少，所以性能相对会好一点。</li><li>小表驱动大表，扫描的行数比较少。</li></ul><p>​    <strong>6.如果需要排序，应考虑对order by涉及的字段加索引，对适合加索引的字段加索引，具体可看索引那一部分。</strong></p><p>​    <strong>理由：</strong></p><ul><li>索引会自动排序的</li></ul><p>​    <strong>7.如果插入数据和删除数据过多，应考虑批量插入和删除，也就是切分查询</strong></p><pre><code class="lang-mysql"># 优化前 删除比id大于10的全部数据delete from user where id&gt;10;# 优化后 一次就删除100条数据 重复很多次就可以delete from user where id&gt;10 limit 100;</code></pre><p>​    <strong>理由：</strong></p><ul><li>批量插入和删除性能好，更加省时间</li></ul><p>​    <strong>8.在适当的时候，使用覆盖索引</strong></p><p>​    <strong>理由：</strong></p><ul><li>覆盖索引能够使得你的SQL语句不需要回表，仅仅访问索引就能够得到所有需要的数据，大大提高了查询效率。</li></ul><p>​    <strong>9.慎用distinct关键字</strong></p><pre><code class="lang-mysql">select name from user;select distinct name from user;</code></pre><p>​    <strong>理由:</strong></p><ul><li>带distinct的语句cpu时间和占用时间都高于不带distinct的语句。因为当查询很多字段时，如果使用distinct，数据库引擎就会对数据进行比较，过滤掉重复数据，然而这个比较，过滤的过程会占用系统资源，cpu时间。</li></ul><p>​    <strong>10. 删除冗余和重复索引</strong></p><p>​    <strong>理由：</strong></p><ul><li>重复的索引需要维护，并且优化器在优化查询的时候也需要逐个地进行考虑，这会影响性能的。例如主键就不需要加索引了，因为主键本来就是一个聚簇索引。</li></ul><p>​    <strong>11.不要有超过5个以上的表连接</strong></p><p>​    <strong>理由：</strong></p><ul><li>连表越多，编译的时间和开销也就越大。</li><li>把连接表拆开成较小的几个执行，可读性更高。</li><li>如果一定需要连接很多表才能得到数据，那么意味着糟糕的设计了。</li></ul><p>​    <strong>12.exist &amp; in的合理利用</strong></p><pre><code class="lang-mysql">select * from A where id in(select id from B)# 等价于 B表驱动A表先查询B表select id from B再由id,查询A表的数据select * from A where A.id=B.idselect * from A where exists(select * from B where A.id=B.id)# 等价于 A表驱动B表先查询A表select * from A再查询B表select * from B where A.id=B.id</code></pre><p>​    <strong>结果：</strong></p><ul><li>B的数据量小于A，适合使用in</li><li>B的数据量大于A，适合使用exists</li></ul><p>​    <strong>理由：</strong></p><ul><li>mysql优化原则，就是小表驱动大表，小的数据集驱动大的数据集，从而让性能更优。</li></ul><p>​    <strong>13.尽量用 union all 替换 union</strong></p><pre><code class="lang-mysql"># 会过滤重复数据select id ,name from user union  select id,name from user# 不会过滤重复数据select id ,name from user union select id,name from user</code></pre><p>​    <strong>理由：</strong></p><ul><li>如果使用union，不管检索结果有没有重复，都会尝试进行合并，然后在输出最终结果前进行排序。如果已知检索结果没有重复记录，使用union all 代替union，这样会提高效率。</li></ul><p>​    <strong>14.索引不宜太多，一般5个以内</strong></p><ul><li>索引并不是越多越好，索引虽然提高了查询的效率，但是也降低了插入和更新的效率。</li><li>insert或update时有可能会重建索引，所以建索引需要慎重考虑，视具体情况来定。</li><li>一个表的索引数最好不要超过5个，若太多需要考虑一些索引是否没有存在的必要。</li></ul><p>​    <strong>15.尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型</strong></p><p>​    <strong>理由：</strong></p><ul><li>相对于数字型字段，字符型会降低查询和连接的性能，并会增加存储开销。</li></ul><p>​    <strong>16.尽可能使用varchar/nvarchar 代替 char/nchar*</strong></p><p>​    <strong>理由：</strong></p><ul><li>因为首先变长字段存储空间小，可以节省存储空间。</li><li>其次对于查询来说，在一个相对较小的字段内搜索，效率更高。</li></ul><p><strong>具体可看：</strong></p><ul><li><a href="https://github.com/whx123/JavaHome/blob/master/Mysql%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/%E4%B9%A6%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FSQL%E7%9A%8430%E6%9D%A1%E5%BB%BA%E8%AE%AE.md" target="_blank" rel="noopener"><strong>书写高质量SQL的30条建议</strong></a></li></ul><h3 id="二、优化数据类型"><a href="#二、优化数据类型" class="headerlink" title="二、优化数据类型"></a>二、优化数据类型</h3><p>​    <strong>1.更小的通常更好，</strong>尽量使用可以正确存储数据的最小数据类型。因为占用更少的磁盘，内存和CPU缓存。</p><p>​    <strong>2.尽量避免NULL，</strong>为NULL的列使索引更复杂。可为NULL的列会使用更多的存储空间。</p><p>​    <strong>3.整型定义中不添加显示长度的值，</strong>例如使用int(4)尽量避免。</p><p>​    <strong>4.尽可能不要使用text，blob类型</strong></p><p>​    <strong>5.不要在数据库中使用varbinary或blob存储图片及文件，</strong>mysql 并不适合大量存储这类型文件</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>布隆过滤器</title>
      <link href="/posts/12923.html"/>
      <url>/posts/12923.html</url>
      
        <content type="html"><![CDATA[<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>​    布隆过滤器可以理解为一个不怎么精确的 set 结构，当你使用它的 contains 方法判断某个对象是否存在时，它可能会误判。但是布隆过滤器也不是特别不精确，只要参数设置的合理，它的精确度可以控制的相对足够精确，只会有小小的误判概率。</p><p>​    当布隆过滤器说某个值存在时，这个值可能不存在；当它说不存在时，那就肯定不存在。打个比方，当它说不认识你时，肯定就不认识；当它说见过你时，可能根本就没见过面，不过因为你的脸跟它认识的人中某脸比较相似 (某些熟脸的系数组合)，所以误判以前见过你。</p><h3 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a>二、原理</h3><p>​    布隆过滤器的原理是，当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。</p><p>​    Bloom Filter跟单哈希函数Bit-Map不同之处在于：Bloom Filter使用了k个哈希函数，每个字符串跟k个bit对应。从而降低了冲突的概率。</p><p><img src="/medias/loading.gif" data-original="https://i.loli.net/2020/12/06/AKYJz8Vtm7dI5Fw.jpg" alt=""></p><h3 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h3><blockquote><p>防止缓存击穿</p></blockquote><p>​    数据库的id都是1开始然后自增的，当接口是通过id查询的，我就拿负数去查询，这个时候，会发现缓存里面没这个数据，我又去数据库查也没有，一个请求这样，100个，1000个，10000个呢？你的DB基本上就扛不住了，如果在缓存里面加上这个，是不是就不存在了，你判断没这个数据就不去查了，直接return一个数据为空不就好了嘛。</p><blockquote><p>其它应用场景</p></blockquote><ul><li>爬虫过滤已抓到的url就不再抓，可用bloom filter过滤</li><li>垃圾邮件过滤。如果用哈希表，每存储一亿个 email地址，就需要 1.6GB的内存（用哈希表实现的具体办法是将每一个 email地址对应成一个八字节的信息指纹，然后将这些信息指纹存入哈希表，由于哈希表的存储效率一般只有 50%，因此一个 email地址需要占用十六个字节。一亿个地址大约要 1.6GB，即十六亿字节的内存）。因此存贮几十亿个邮件地址可能需要上百 GB的内存。而Bloom Filter只需要哈希表 1/8到 1/4 的大小就能解决同样的问题。</li><li>做推荐系统，要将之前推荐过的商品给去掉，可以使用bloom filter过滤</li></ul><h3 id="四、数学推导"><a href="#四、数学推导" class="headerlink" title="四、数学推导"></a>四、数学推导</h3><h4 id="误判概率的计算"><a href="#误判概率的计算" class="headerlink" title="误判概率的计算"></a>误判概率的计算</h4><p>​    假设布隆过滤器中的散列函数满足：每个元素都等概率的hash到m个bit中的任何一个，与其它元素被hash到哪个bit无关。若m为bit数，则对某一特定bit位在一个元素由某特定散列函数插入时没有被置位为1的概率为：</p><script type="math/tex; mode=display">1-\frac{1}{m}</script><p>​    则k个散列函数没有一个对其置位的概率为：</p><script type="math/tex; mode=display">(1-\frac{1}{m})^k</script><p>​    如果插入了n个元素，但都未将其置位的概率为：</p><script type="math/tex; mode=display">(1-\frac{1}{m})^{kn}</script><p>​    则此特定bit位被置位的概率为：</p><script type="math/tex; mode=display">1-(1-\frac{1}{m})^{kn}</script><p>​    当考虑查找的时候，因为有k个散列函数，则对应元素应该有k个bit。若对应元素的k bits全部被置位为1，则可判定其在集合中。因此将某元素误判的概率为：</p><script type="math/tex; mode=display">(1-(1-\frac{1}{m})^{kn})^k</script><script type="math/tex; mode=display">由于\lim_{x\rightarrow+\infty}(1+\frac{1}{x})^x=e,并且x趋于+\infty \\\lim_{m\rightarrow+\infty}(1-\frac{1}{m})^{-m}=e\\(1-(1-\frac{1}{m})^{kn})^k=(1-(1-\frac{1}{m})^{-m\frac{-kn}{m}})^k=(1-e^\frac{-kn}{m})^k</script><p>​    从上式可以看出，当m增大或n减小，都会是得误判率减小。</p><p>​    现在计算对于给定的m和n，k为何值时可以使得误判率最低。设误判率为k的函数为：</p><script type="math/tex; mode=display">f(k)=(1-e^\frac{-kn}{m})^k</script><script type="math/tex; mode=display">设b=e^\frac{n}{m},则简化为\\f(k)=(1-b^{-k})^k</script><p>​    采用对数求导法，该方法将幂函数、指数函数及幂指函数运算降格成为乘法运算，可将乘法运算或除法运算降格为加法或减法运算，使求导运算计算量大为减少。</p><script type="math/tex; mode=display">lnf(k)=k*ln(1-b^{-k}),两边对k求导\\\frac{1}{f(k)}*f'(k)=ln(1-b^{-k})+k*\frac{1}{1-b^{-k}}*(-b^{-k})*lnb*(-1)=ln(1-b^{-k})+k*\frac{b^{-k}lnb}{1-b^{-k}})\\f'(k)=(ln(1-b^{-k})+k*\frac{b^{-k}lnb}{1-b^{-k}})*f(k)</script><p>​    下面求最值</p><script type="math/tex; mode=display">(ln(1-b^{-k})+k*\frac{b^{-k}lnb}{1-b^{-k}})*f(k)=0\\ln(1-b^{-k})+k*\frac{b^{-k}lnb}{1-b^{-k}}=0\\(1-b^{-k})*ln(1-b^{-k})=-k*b^{-k}*lnb\\(1-b^{-k})*ln(1-b^{-k})=b^{-k}*lnb^{-k}\\1-b^{-k}=b^{-k}\\b^{-k}=\frac{1}{2}\\e^\frac{-kn}{m}=\frac{1}{2}\\\frac{-kn}{m}=ln\frac{1}{2}\\k=ln2*\frac{m}{n}</script><p>​    因此当k满足上式时误判率是最低的，此时误判率P为：</p><script type="math/tex; mode=display">P=(1-e^\frac{-kn}{m})^k=(1-e^{-ln2})^k=(1-\frac{1}{2})^k=2^{-k}=2^{-ln2\frac{m}{n}}</script><p>​    当误判率小于等于1/2，则</p><script type="math/tex; mode=display">2^{-k}\leq\frac{1}{2}\\2^{-k}\leq2^{-1}\\k\geq1\\\frac{m}{n}\geq\frac{1}{ln2}</script><p>​    </p><p>​    这说明了若想保持某固定误判率不变，布隆过滤器的bit数m与被add的元素数n应该是线性同步增加的。</p><h4 id="设计克隆过滤器"><a href="#设计克隆过滤器" class="headerlink" title="设计克隆过滤器"></a>设计克隆过滤器</h4><p>​    首先要先由用户决定要add的元素数n和希望的误差率P。这也是一个设计完整的布隆过滤器需要用户输入的仅有的两个参数，之后的所有参数将由系统计算，并由此建立布隆过滤器。</p><p>​    系统首先要计算需要的内存大小m bits：</p><script type="math/tex; mode=display">P=2^{-ln2\frac{m}{n}}\\lnP=ln2*(-ln2)*\frac{m}{n}\\m=-\frac{n*lnP}{(ln2)^2}</script><p>​    </p><p>​    再由m，n得到散列函数的个数：</p><script type="math/tex; mode=display">k=ln2*\frac{m}{n}</script><p>​    根据公式，当k最优时：</p><script type="math/tex; mode=display">P=2^{-k}\\\log_2P=-k\\k=\log_2\frac{1}{P}\\ln2*\frac{m}{n}=\log_2\frac{1}{P}\\\frac{m}{n}=\frac{\log_2\frac{1}{P}}{ln2}\\\frac{m}{n}=\log_2\frac{1}{P}*1.44\\</script><p>​    当P=1%时，m为内存会计，n为元素个数则存储每个元素需要9.6bits：</p><script type="math/tex; mode=display">\frac{m}{n}=1.44*\log_2\frac{1}{0.01}=1.44*\log_2100=9.6bits</script><p>​    这里需要特别注意的是，9.6 bits不仅包含了被置为1的k位，还把包含了没有被置为1的一些位数。此时的k</p><script type="math/tex; mode=display">k=ln2*\frac{m}{n}=ln2*9.6=6.65bits才是对应的为1的bit位数</script><h3 id="五、实现"><a href="#五、实现" class="headerlink" title="五、实现"></a>五、实现</h3><h4 id="使用准备"><a href="#使用准备" class="headerlink" title="使用准备"></a>使用准备</h4><pre><code class="lang-xml">&lt;dependency&gt;    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;    &lt;artifactId&gt;guava&lt;/artifactId&gt;    &lt;version&gt;23.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><pre><code class="lang-java">public class TestBloomFilter {    //添加的元素数量    private static int total=1000000;    private static BloomFilter&lt;Integer&gt; bloomFilter=BloomFilter.create(Funnels.integerFunnel(),total);    public static void main(String[] args) {        // 初始化1000000条数据到过滤器中        for(int i=0;i&lt;total;i++){            bloomFilter.put(i);        }         // 匹配已在过滤器中的值，是否有匹配不上的        for(int i=0;i&lt;total;i++){            if(!bloomFilter.mightContain(i)){                System.out.println(&quot;有坏人逃脱了~~~&quot;);            }        }         // 匹配不在过滤器中的10000个值，有多少匹配出来        int count=0;        for(int i=total;i&lt;total+10000;i++){            if(bloomFilter.mightContain(i)){                count++;            }        }        System.out.println(&quot;误伤的数量：&quot; + count);    }}</code></pre><p>​    运行结果表示，遍历这一百万个在过滤器中的数时，都被识别出来了。一万个不在过滤器中的数，误伤了320个，错误率是0.03左右。</p><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><blockquote><p>创建对象</p></blockquote><pre><code class="lang-java">public static &lt;T&gt; BloomFilter&lt;T&gt; create(Funnel&lt;? super T&gt; funnel, int expectedInsertions) {        return create(funnel, (long) expectedInsertions);    }      public static &lt;T&gt; BloomFilter&lt;T&gt; create(Funnel&lt;? super T&gt; funnel, long expectedInsertions) {        return create(funnel, expectedInsertions, 0.03); // FYI, for 3%, we always get 5 hash functions    }    public static &lt;T&gt; BloomFilter&lt;T&gt; create(          Funnel&lt;? super T&gt; funnel, long expectedInsertions, double fpp) {        return create(funnel, expectedInsertions, fpp, BloomFilterStrategies.MURMUR128_MITZ_64);    }    static &lt;T&gt; BloomFilter&lt;T&gt; create(      Funnel&lt;? super T&gt; funnel, long expectedInsertions, double fpp, Strategy strategy) {     ......    }</code></pre><p>BloomFilter一共四个create方法，不过最终都是走向第四个。看一下每个参数的含义：</p><ul><li>funnel：数据类型(一般是调用Funnels工具类中的)</li><li>expectedInsertions：期望插入的值的个数</li><li>fpp ： 错误率(默认值为0.03)</li><li>strategy： 哈希算法</li></ul><blockquote><p>分析create方法</p></blockquote><pre><code class="lang-java">static &lt;T&gt; BloomFilter&lt;T&gt; create(      Funnel&lt;? super T&gt; funnel, long expectedInsertions, double fpp, Strategy strategy) {    if (expectedInsertions == 0) {      expectedInsertions = 1;    }       //计算内存，通过插入的值的个数和错误率来计算    long numBits = optimalNumOfBits(expectedInsertions, fpp);    //计算散列函数的个数    int numHashFunctions = optimalNumOfHashFunctions(expectedInsertions, numBits);    try {        //创建对象      return new BloomFilter&lt;T&gt;(new LockFreeBitArray(numBits), numHashFunctions, funnel, strategy);    } catch (IllegalArgumentException e) {      throw new IllegalArgumentException(&quot;Could not create BloomFilter of &quot; + numBits + &quot; bits&quot;, e);    }  }</code></pre><pre><code class="lang-java">//计算内存，通过插入的值的个数和错误率来计算static long optimalNumOfBits(long n, double p) {    if (p == 0) {      p = Double.MIN_VALUE;    }    return (long) (-n * Math.log(p) / (Math.log(2) * Math.log(2)));  }</code></pre><p>对应公式：</p><script type="math/tex; mode=display">m=-\frac{n*lnP}{(ln2)^2}</script><pre><code class="lang-java">//计算散列函数的个数static int optimalNumOfHashFunctions(long n, long m) {    // (m / n) * log(2), but avoid truncation due to division!    return Math.max(1, (int) Math.round((double) m / n * Math.log(2)));  }</code></pre><p>对应公式：</p><script type="math/tex; mode=display">k=ln2*\frac{m}{n}</script>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
